<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Chapter 4. Data Management</title>
    <link rel="stylesheet" type="text/css" href="../style.css"/>
    <meta name="generator" content="DocBook XSL Stylesheets V1.79.2"/>
    <link rel="prev" href="postgis_administration.html" title="Chapter 3. PostGIS Administration"/>
    <link rel="next" href="using_postgis_query.html" title="Chapter 5. Spatial Queries"/>
  </head>
  <body>
    <header>
      <div class="navheader">
        <table style="width: 100%; ">
          <tr>
            <th style="text-align: center; " colspan="3">Chapter 4. Data Management</th>
          </tr>
          <tr>
            <td style="width: 20%; text-align: left; "><a accesskey="p" href="postgis_administration.html">Prev</a> </td>
            <th style="width: 60%; text-align: center; "> </th>
            <td style="width: 20%; text-align: right; "> <a accesskey="n" href="using_postgis_query.html">Next</a></td>
          </tr>
        </table>
      </div>
    </header>
    <section class="chapter" id="using_postgis_dbmanagement">
      <div class="titlepage">
        <div>
          <div>
            <h1 class="title">Chapter 4. Data Management</h1>
          </div>
        </div>
      </div>
      <div class="toc">
        <div class="toc-title">Table of Contents</div>
        <ul class="toc">
          <li>
            <span class="section">
              <a href="using_postgis_dbmanagement.html#RefObject">4.1. Spatial Data Model</a>
            </span>
          </li>
          <li>
            <span class="section">
              <a href="using_postgis_dbmanagement.html#PostGIS_Geometry">4.2. Geometry Data Type</a>
            </span>
          </li>
          <li>
            <span class="section">
              <a href="using_postgis_dbmanagement.html#PostGIS_Geography">4.3. Geography Data Type</a>
            </span>
          </li>
          <li>
            <span class="section">
              <a href="using_postgis_dbmanagement.html#OGC_Validity">4.4. Geometry Validation</a>
            </span>
          </li>
          <li>
            <span class="section">
              <a href="using_postgis_dbmanagement.html#spatial_ref_sys">4.5. Spatial Reference Systems</a>
            </span>
          </li>
          <li>
            <span class="section">
              <a href="using_postgis_dbmanagement.html#idm2036">4.6. Spatial Tables</a>
            </span>
          </li>
          <li>
            <span class="section">
              <a href="using_postgis_dbmanagement.html#loading-data">4.7. Loading Spatial Data</a>
            </span>
          </li>
          <li>
            <span class="section">
              <a href="using_postgis_dbmanagement.html#extracting-data">4.8. Extracting Spatial Data</a>
            </span>
          </li>
          <li>
            <span class="section">
              <a href="using_postgis_dbmanagement.html#build-indexes">4.9. Spatial Indexes</a>
            </span>
          </li>
        </ul>
      </div>
      <section class="section" id="RefObject">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">4.1. Spatial Data Model</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <ul class="toc">
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#OGC_Geometry">4.1.1. OGC Geometry</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#SQL_MM_Part3">4.1.2. SQL/MM Part 3 - Curves</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#OpenGISWKBWKT">4.1.3. WKT and WKB</a>
              </span>
            </li>
          </ul>
        </div>
        <section class="section" id="OGC_Geometry">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.1.1. OGC Geometry</h3>
              </div>
            </div>
          </div>
          <div class="toc">
            <ul class="toc">
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#Point">4.1.1.1. Point</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#LineString">4.1.1.2. LineString</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#LinearRing">4.1.1.3. LinearRing</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#Polygon">4.1.1.4. Polygon</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#MultiPoint">4.1.1.5. MultiPoint</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#MultiLineString">4.1.1.6. MultiLineString</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#MultiPolygon">4.1.1.7. MultiPolygon</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#GeometryCollection">4.1.1.8. GeometryCollection</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#PolyhedralSurface">4.1.1.9. PolyhedralSurface</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#Triangle">4.1.1.10. Triangle</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#TIN">4.1.1.11. TIN</a>
                </span>
              </li>
            </ul>
          </div>
          <p>The Open Geospatial Consortium (OGC) developed the
    <a class="link" href="https://www.ogc.org/standards/sfa" target="_top"><span class="emphasis"><em>Simple Features Access</em></span></a>
    standard (SFA) to provide a model for geospatial data.
    It defines the fundamental spatial type of <span class="bold"><strong>Geometry</strong></span>,
    along with operations which manipulate and transform geometry values
    to perform spatial analysis tasks.
    PostGIS implements the OGC Geometry model as the PostgreSQL data types
    <a class="link" href="using_postgis_dbmanagement.html#PostGIS_Geometry" title="4.2. Geometry Data Type">geometry</a> and
    <a class="link" href="using_postgis_dbmanagement.html#PostGIS_Geography" title="4.3. Geography Data Type">geography</a>.
    </p>
          <p>
    Geometry is an <span class="emphasis"><em>abstract</em></span> type.
    Geometry values belong to one of its <span class="emphasis"><em>concrete</em></span> subtypes
    which represent various kinds and dimensions of geometric shapes.
    These include the <span class="bold"><strong>atomic</strong></span> types
    <a class="link" href="using_postgis_dbmanagement.html#Point" title="4.1.1.1. Point">Point</a>,
    <a class="link" href="using_postgis_dbmanagement.html#LineString" title="4.1.1.2. LineString">LineString</a>,
    <a class="link" href="using_postgis_dbmanagement.html#LinearRing" title="4.1.1.3. LinearRing">LinearRing</a> and
    <a class="link" href="using_postgis_dbmanagement.html#Polygon" title="4.1.1.4. Polygon">Polygon</a>,
    and the <span class="bold"><strong>collection</strong></span> types
    <a class="link" href="using_postgis_dbmanagement.html#MultiPoint" title="4.1.1.5. MultiPoint">MultiPoint</a>,
    <a class="link" href="using_postgis_dbmanagement.html#MultiLineString" title="4.1.1.6. MultiLineString">MultiLineString</a>,
    <a class="link" href="using_postgis_dbmanagement.html#MultiPolygon" title="4.1.1.7. MultiPolygon">MultiPolygon</a> and
    <a class="link" href="using_postgis_dbmanagement.html#GeometryCollection" title="4.1.1.8. GeometryCollection">GeometryCollection</a>.
    The <a class="link" href="https://portal.ogc.org/files/?artifact_id=25355" target="_top"><span class="emphasis"><em>Simple Features Access - Part 1: Common architecture v1.2.1</em></span></a>
    adds subtypes for the structures
    <a class="link" href="using_postgis_dbmanagement.html#PolyhedralSurface" title="4.1.1.9. PolyhedralSurface">PolyhedralSurface</a>,
    <a class="link" href="using_postgis_dbmanagement.html#Triangle" title="4.1.1.10. Triangle">Triangle</a> and
    <a class="link" href="using_postgis_dbmanagement.html#TIN" title="4.1.1.11. TIN">TIN</a>.
    </p>
          <p>Geometry models shapes in the 2-dimensional Cartesian plane.
    The PolyhedralSurface, Triangle, and TIN types can also represent shapes in 3-dimensional space.
    The size and location of shapes are specified by their <span class="bold"><strong>coordinates</strong></span>.
    Each coordinate has a X and Y <span class="bold"><strong>ordinate</strong></span> value determining its location in the plane.
    Shapes are constructed from points or line segments, with points specified by a single coordinate,
    and line segments by two coordinates.
    </p>
          <p>Coordinates may contain optional Z and M ordinate values.
    The Z ordinate is often used to represent elevation.
    The M ordinate contains a measure value, which may represent time or distance.
    If Z or M values are present in a geometry value, they must be defined for each point in the geometry.
    If a geometry has Z or M ordinates the <span class="bold"><strong>coordinate dimension</strong></span> is 3D;
    if it has both Z and M the coordinate dimension is 4D.
    </p>
          <p>Geometry values are associated with a
    <span class="bold"><strong>spatial reference system</strong></span>
    indicating the coordinate system in which it is embedded.
    The spatial reference system is identified by the geometry SRID number.
    The units of the X and Y axes are determined by the spatial reference system.
    In <span class="bold"><strong>planar</strong></span> reference systems the X and Y coordinates typically
    represent easting and northing,
    while in <span class="bold"><strong>geodetic</strong></span> systems
    they represent longitude and latitude.
    SRID 0 represents an infinite Cartesian plane with no units assigned to its axes.
    See <a class="xref" href="using_postgis_dbmanagement.html#spatial_ref_sys" title="4.5. Spatial Reference Systems">Section 4.5, “Spatial Reference Systems”</a>.
    </p>
          <p>The geometry <span class="bold"><strong>dimension</strong></span> is a property of geometry types.
    Point types have dimension 0, linear types have dimension 1,
    and polygonal types have dimension 2.
    Collections have the dimension of the maximum element dimension.
    </p>
          <p>A geometry value may be <span class="bold"><strong>empty</strong></span>.
    Empty values contain no vertices (for atomic geometry types)
    or no elements (for collections).
    </p>
          <p>An important property of geometry values is their spatial
    <span class="bold"><strong>extent</strong></span> or <span class="bold"><strong>bounding box</strong></span>,
    which the OGC model calls <span class="bold"><strong>envelope</strong></span>.
    This is the 2 or 3-dimensional box which encloses the coordinates of a geometry.
    It is an efficient way to represent a geometry's
    extent in coordinate space and to check whether two geometries interact.
   </p>
          <p>The geometry model allows evaluating topological spatial relationships as
    described in  <a class="xref" href="using_postgis_query.html#DE-9IM" title="5.1.1. Dimensionally Extended 9-Intersection Model">Section 5.1.1, “Dimensionally Extended 9-Intersection Model”</a>.
    To support this the concepts of
    <span class="bold"><strong>interior</strong></span>,
    <span class="bold"><strong>boundary</strong></span> and
    <span class="bold"><strong>exterior</strong></span>
    are defined for each geometry type.
    Geometries are topologically closed, so they always contain their boundary.
    The boundary is a geometry of dimension one less than that of the geometry itself.
    </p>
          <p>The OGC geometry model defines validity rules for each geometry type.
    These rules ensure that geometry values represents realistic
    situations (e.g. it is possible to specify a polygon
    with a hole lying outside the shell, but this makes no sense geometrically
    and is thus invalid).
    PostGIS also allows storing and manipulating invalid geometry values.
    This allows detecting and fixing them if needed.
    See <a class="xref" href="using_postgis_dbmanagement.html#OGC_Validity" title="4.4. Geometry Validation">Section 4.4, “Geometry Validation”</a>
    </p>
          <section class="section" id="Point">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.1. Point</h4>
                </div>
              </div>
            </div>
            <p>A Point is a 0-dimensional geometry that represents a single location in coordinate space.</p>
            <pre class="programlisting">POINT (1 2)
POINT Z (1 2 3)
POINT ZM (1 2 3 4)
</pre>
          </section>
          <section class="section" id="LineString">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.2. LineString</h4>
                </div>
              </div>
            </div>
            <p>A LineString is a 1-dimensional line formed by a contiguous sequence of line segments.
        Each line segment is defined by two points, with the end point of one segment
        forming the start point of the next segment.
        An OGC-valid LineString has either zero or two or more points,
        but PostGIS also allows single-point LineStrings.
        LineStrings may cross themselves (self-intersect).
        A LineString is <span class="bold"><strong>closed</strong></span> if the start and end points are the same.
        A LineString is <span class="bold"><strong>simple</strong></span> if it does not self-intersect.
        </p>
            <pre class="programlisting">LINESTRING (1 2, 3 4, 5 6)</pre>
          </section>
          <section class="section" id="LinearRing">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.3. LinearRing</h4>
                </div>
              </div>
            </div>
            <p>A LinearRing is a LineString which is both closed and simple.
        The first and last points must be equal, and the line must not self-intersect.</p>
            <pre class="programlisting">LINEARRING (0 0 0, 4 0 0, 4 4 0, 0 4 0, 0 0 0)</pre>
          </section>
          <section class="section" id="Polygon">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.4. Polygon</h4>
                </div>
              </div>
            </div>
            <p>A Polygon is a 2-dimensional planar region,
        delimited by an exterior boundary (the shell)
        and zero or more interior boundaries (holes).
        Each boundary is a <a class="link" href="using_postgis_dbmanagement.html#LinearRing" title="4.1.1.3. LinearRing">LinearRing</a>.
        </p>
            <pre class="programlisting">POLYGON ((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))</pre>
          </section>
          <section class="section" id="MultiPoint">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.5. MultiPoint</h4>
                </div>
              </div>
            </div>
            <p>A MultiPoint is a collection of Points.</p>
            <pre class="programlisting">MULTIPOINT ( (0 0), (1 2) )</pre>
          </section>
          <section class="section" id="MultiLineString">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.6. MultiLineString</h4>
                </div>
              </div>
            </div>
            <p>A MultiLineString is a collection of LineStrings.
        A MultiLineString is closed if each of its elements is closed.
        </p>
            <pre class="programlisting">MULTILINESTRING ( (0 0,1 1,1 2), (2 3,3 2,5 4) )</pre>
          </section>
          <section class="section" id="MultiPolygon">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.7. MultiPolygon</h4>
                </div>
              </div>
            </div>
            <p>A MultiPolygon is a collection of non-overlapping, non-adjacent Polygons.
        Polygons in the collection may touch only at a finite number of points.
        </p>
            <pre class="programlisting">MULTIPOLYGON (((1 5, 5 5, 5 1, 1 1, 1 5)), ((6 5, 9 1, 6 1, 6 5)))</pre>
          </section>
          <section class="section" id="GeometryCollection">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.8. GeometryCollection</h4>
                </div>
              </div>
            </div>
            <p>A GeometryCollection is a heterogeneous (mixed) collection of geometries.</p>
            <pre class="programlisting">GEOMETRYCOLLECTION ( POINT(2 3), LINESTRING(2 3, 3 4))</pre>
          </section>
          <section class="section" id="PolyhedralSurface">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.9. PolyhedralSurface</h4>
                </div>
              </div>
            </div>
            <p>A PolyhedralSurface is a contiguous collection of patches or facets which share some edges.
        Each patch is a planar Polygon.
        If the Polygon coordinates have Z ordinates then the surface is 3-dimensional.</p>
            <pre class="programlisting">POLYHEDRALSURFACE Z (
  ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),
  ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)),
  ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),
  ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),
  ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)),
  ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )</pre>
          </section>
          <section class="section" id="Triangle">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.10. Triangle</h4>
                </div>
              </div>
            </div>
            <p>A Triangle is a polygon defined by three distinct non-collinear vertices.
            Because a Triangle is a polygon it is specified by four coordinates,
            with the first and fourth being equal.
        </p>
            <pre class="programlisting">TRIANGLE ((0 0, 0 9, 9 0, 0 0))</pre>
          </section>
          <section class="section" id="TIN">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.1.11. TIN</h4>
                </div>
              </div>
            </div>
            <p>A TIN is a collection of non-overlapping
            <a class="link" href="using_postgis_dbmanagement.html#Triangle" title="4.1.1.10. Triangle">Triangle</a>s representing a
            <a class="link" href="https://en.wikipedia.org/wiki/Triangulated_irregular_network" target="_top">Triangulated Irregular Network</a>.
        </p>
            <pre class="programlisting">TIN Z ( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )</pre>
          </section>
        </section>
        <section class="section" id="SQL_MM_Part3">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.1.2. SQL/MM Part 3 - Curves</h3>
              </div>
            </div>
          </div>
          <div class="toc">
            <ul class="toc">
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#CircularString">4.1.2.1. CircularString</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#CompoundCurve">4.1.2.2. CompoundCurve</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#CurvePolygon">4.1.2.3. CurvePolygon</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#MultiCurve">4.1.2.4. MultiCurve</a>
                </span>
              </li>
              <li>
                <span class="section">
                  <a href="using_postgis_dbmanagement.html#MultiSurface">4.1.2.5. MultiSurface</a>
                </span>
              </li>
            </ul>
          </div>
          <p>The
      <a class="link" href="https://www.iso.org/obp/ui/#iso:std:iso-iec:13249:-3:ed-5:v1:en" target="_top"><span class="emphasis"><em>ISO/IEC 13249-3 SQL Multimedia - Spatial</em></span></a>
      standard (SQL/MM) extends the
	  OGC SFA to define Geometry subtypes containing curves with circular arcs.
      The SQL/MM types support 3DM, 3DZ and 4D coordinates.
	  </p>
          <div class="note">
            <table style="border: 0; ">
              <tr>
                <td style="text-align: center; vertical-align: top; width: 25px; " rowspan="2">
                  <img alt="[Note]" src="../images/note.png"/>
                </td>
                <th style="text-align: left; "/>
              </tr>
              <tr>
                <td style="text-align: left; vertical-align: top; ">
                  <p>All floating point comparisons within the SQL-MM implementation
		are performed to a specified tolerance, currently 1E-8.</p>
                </td>
              </tr>
            </table>
          </div>
          <section class="section" id="CircularString">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.2.1. CircularString</h4>
                </div>
              </div>
            </div>
            <p>CircularString is the basic curve type, similar to a
        LineString in the linear world.  A single arc segment is specified by three
        points: the start and end points (first and third) and some other
        point on the arc.
        To specify a closed circle the start and end points are the same
        and the middle point is the opposite point on the circle diameter
        (which is the center of the arc).
        In a sequence of arcs the end point of the previous
        arc is the start point of the next arc, just like the segments of a LineString.
        This means that a CircularString must have an
        odd number of points greater than 1.</p>
            <pre class="programlisting">CIRCULARSTRING(0 0, 1 1, 1 0)

CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)</pre>
          </section>
          <section class="section" id="CompoundCurve">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.2.2. CompoundCurve</h4>
                </div>
              </div>
            </div>
            <p>A CompoundCurve is a single continuous curve that may contain both
        circular arc segments and linear segments.  That means that
        in addition to having well-formed components, the end point of
        every component (except the last) must be coincident with the
        start point of the following component.</p>
            <pre class="programlisting">COMPOUNDCURVE( CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))</pre>
          </section>
          <section class="section" id="CurvePolygon">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.2.3. CurvePolygon</h4>
                </div>
              </div>
            </div>
            <p>A CurvePolygon is like a polygon, with an outer ring
        and zero or more inner rings.  The difference is that a ring can be a
        CircularString or CompoundCurve as well as a LineString.
        </p>
            <p>As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon.</p>
            <pre class="programlisting">CURVEPOLYGON(
  CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),
  (1 1, 3 3, 3 1, 1 1) )</pre>
            <p>Example: A CurvePolygon with the shell defined by a CompoundCurve
        containing a CircularString and a LineString,
        and a hole defined by a CircularString</p>
            <pre class="programlisting">CURVEPOLYGON(
  COMPOUNDCURVE( CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),
                 (4 3, 4 5, 1 4, 0 0)),
  CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )</pre>
          </section>
          <section class="section" id="MultiCurve">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.2.4. MultiCurve</h4>
                </div>
              </div>
            </div>
            <p>A MultiCurve is a collection of curves which can include
        LineStrings, CircularStrings or CompoundCurves.</p>
            <pre class="programlisting">MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4))</pre>
          </section>
          <section class="section" id="MultiSurface">
            <div class="titlepage">
              <div>
                <div>
                  <h4 class="title">4.1.2.5. MultiSurface</h4>
                </div>
              </div>
            </div>
            <p>A MultiSurface is a collection of surfaces, which can be (linear)
        Polygons or CurvePolygons.</p>
            <pre class="programlisting">MULTISURFACE(
  CURVEPOLYGON(
    CIRCULARSTRING( 0 0, 4 0, 4 4, 0 4, 0 0),
    (1 1, 3 3, 3 1, 1 1)),
  ((10 10, 14 12, 11 10, 10 10), (11 11, 11.5 11, 11 11.5, 11 11)))</pre>
          </section>
        </section>
        <section class="section" id="OpenGISWKBWKT">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.1.3. WKT and WKB</h3>
              </div>
            </div>
          </div>
          <p>The OGC SFA specification defines two formats for representing
	  geometry values for external use: Well-Known Text (WKT) and Well-Known
	  Binary (WKB). Both WKT and WKB include information about the type
	  of the object and the coordinates which define it.</p>
          <p>Well-Known Text (WKT) provides a standard textual representation of spatial data.
      Examples of WKT representations of spatial objects are:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>POINT(0 0)</p>
              </li>
              <li class="listitem">
                <p>POINT Z (0 0 0)</p>
              </li>
              <li class="listitem">
                <p>POINT ZM (0 0 0 0)</p>
              </li>
              <li class="listitem">
                <p>POINT EMPTY</p>
              </li>
              <li class="listitem">
                <p>LINESTRING(0 0,1 1,1 2)</p>
              </li>
              <li class="listitem">
                <p>LINESTRING EMPTY</p>
              </li>
              <li class="listitem">
                <p>POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))</p>
              </li>
              <li class="listitem">
                <p>MULTIPOINT((0 0),(1 2))</p>
              </li>
              <li class="listitem">
                <p>MULTIPOINT Z ((0 0 0),(1 2 3))</p>
              </li>
              <li class="listitem">
                <p>MULTIPOINT EMPTY</p>
              </li>
              <li class="listitem">
                <p>MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))</p>
              </li>
              <li class="listitem">
                <p>MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)),
		  ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))</p>
              </li>
              <li class="listitem">
                <p>GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))</p>
              </li>
              <li class="listitem">
                <p>GEOMETRYCOLLECTION EMPTY</p>
              </li>
            </ul>
          </div>
          <p>Input and output of WKT is provided by the functions
      <a class="xref" href="ST_AsText.html" title="ST_AsText">ST_AsText</a> and <a class="xref" href="ST_GeomFromText.html" title="ST_GeomFromText">ST_GeomFromText</a>:</p>
          <pre class="programlisting">text WKT = ST_AsText(geometry);
geometry = ST_GeomFromText(text WKT, SRID);</pre>
          <p>For example, a statement to create and insert a spatial object from WKT and a SRID is:</p>
          <pre class="programlisting">INSERT INTO geotable ( geom, name )
  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');</pre>
          <p>Well-Known Binary (WKB) provides a portable, full-precision representation
      of spatial data as binary data (arrays of bytes).
      Examples of the WKB representations of spatial objects are:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>WKT: POINT(1 1)</p>
                <p>WKB: 0101000000000000000000F03F000000000000F03</p>
              </li>
              <li class="listitem">
                <p>WKT: LINESTRING (2 2, 9 9)</p>
                <p>WKB: 0102000000020000000000000000000040000000000000004000000000000022400000000000002240</p>
              </li>
            </ul>
          </div>
          <p>Input and output of WKB is provided by the functions
    <a class="xref" href="ST_AsBinary.html" title="ST_AsBinary">ST_AsBinary</a> and <a class="xref" href="ST_GeomFromWKB.html" title="ST_GeomFromWKB">ST_GeomFromWKB</a>:</p>
          <pre class="programlisting">
bytea WKB = ST_AsBinary(geometry);
geometry = ST_GeomFromWKB(bytea WKB, SRID);
</pre>
          <p>For example, a statement to create and insert a
	  spatial object from WKB is:</p>
          <pre class="programlisting">INSERT INTO geotable ( geom, name )
  VALUES ( ST_GeomFromWKB('\x0101000000000000000000f03f000000000000f03f', 312), 'A Place');</pre>
        </section>
      </section>
      <section class="section" id="PostGIS_Geometry">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">4.2. Geometry Data Type</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <ul class="toc">
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#EWKB_EWKT">4.2.1. PostGIS EWKB and EWKT</a>
              </span>
            </li>
          </ul>
        </div>
        <p>PostGIS implements the OGC Simple Features model
    by defining a PostgreSQL data type called <code class="varname">geometry</code>.
    It represents all of the geometry subtypes by using an internal type code
    (see <a class="xref" href="GeometryType.html" title="GeometryType">GeometryType</a> and <a class="xref" href="ST_GeometryType.html" title="ST_GeometryType">ST_GeometryType</a>).
    This allows modelling spatial features as rows of tables defined
    with a column of type <code class="varname">geometry</code>.
    </p>
        <p>The <code class="varname">geometry</code> data type is <span class="emphasis"><em>opaque</em></span>,
    which means that all access is done via invoking functions on geometry values.
    Functions allow creating geometry objects,
    accessing or updating all internal fields,
    and compute new geometry values.
    PostGIS supports all the functions specified in the OGC
	<a class="link" href="https://portal.ogc.org/files/?artifact_id=25354" target="_top"><span class="emphasis"><em>Simple feature access - Part 2: SQL option</em></span></a>
    (SFS) specification, as well many others.
    See <a class="xref" href="reference.html" title="Chapter 7. PostGIS Reference">Chapter 7, <em>PostGIS Reference</em></a> for the full list of functions.</p>
        <div class="note">
          <table style="border: 0; ">
            <tr>
              <td style="text-align: center; vertical-align: top; width: 25px; " rowspan="2">
                <img alt="[Note]" src="../images/note.png"/>
              </td>
              <th style="text-align: left; "/>
            </tr>
            <tr>
              <td style="text-align: left; vertical-align: top; ">
                <p>PostGIS follows the SFA standard by prefixing spatial functions with "ST_".
        This was intended to stand for "Spatial and Temporal",
        but the temporal part of the standard was never developed.
        Instead it can be interpreted as "Spatial Type".
        </p>
              </td>
            </tr>
          </table>
        </div>
        <p>The SFA standard specifies that spatial objects include a Spatial Reference System
    identifier (SRID). The SRID is required when creating spatial objects
    for insertion into the database (it may be defaulted to 0).
    See <a class="xref" href="ST_SRID.html" title="ST_SRID">ST_SRID</a> and <a class="xref" href="using_postgis_dbmanagement.html#spatial_ref_sys" title="4.5. Spatial Reference Systems">Section 4.5, “Spatial Reference Systems”</a></p>
        <p>To make querying geometry efficient PostGIS defines
    various kinds of spatial indexes, and spatial operators to use them.
    See <a class="xref" href="using_postgis_dbmanagement.html#build-indexes" title="4.9. Spatial Indexes">Section 4.9, “Spatial Indexes”</a> and <a class="xref" href="using_postgis_query.html#using-query-indexes" title="5.2. Using Spatial Indexes">Section 5.2, “Using Spatial Indexes”</a> for details.
    </p>
        <section class="section" id="EWKB_EWKT">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.2.1. PostGIS EWKB and EWKT</h3>
              </div>
            </div>
          </div>
          <p>OGC SFA specifications initially supported only 2D geometries,
		and the geometry SRID is not included in the input/output representations.
        The OGC SFA specification 1.2.1 (which aligns with the ISO 19125 standard)
        adds support for 3D (ZYZ) and measured (XYM and XYZM) coordinates,
		but still does not include the SRID value.</p>
          <p>Because of these limitations PostGIS defined extended EWKB and EWKT formats.
        They provide 3D (XYZ and XYM) and 4D (XYZM) coordinate support and include SRID information.
        Including all geometry information allows PostGIS to use EWKB as the format of record
        (e.g. in DUMP files).
        </p>
          <p>EWKB and EWKT are used for the "canonical forms" of PostGIS data objects.
        For input, the canonical form for binary data is EWKB,
        and for text data either EWKB or EWKT is accepted.
        This allows geometry values to be created by casting
        a text value in either HEXEWKB or EWKT to a geometry value using <code class="varname">::geometry</code>.
        For output, the canonical form for binary is EWKB, and for text
        it is HEXEWKB (hex-encoded EWKB).
        </p>
          <p>For example this statement creates a geometry by casting from an EWKT text value,
        and outputs it using the canonical form of HEXEWKB:</p>
          <pre class="programlisting">SELECT 'SRID=4;POINT(0 0)'::geometry;
  geometry
  ----------------------------------------------------
  01010000200400000000000000000000000000000000000000
</pre>
          <p>PostGIS EWKT output has a few differences to OGC WKT:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>For 3DZ geometries the Z qualifier is omitted:</p>
                <p>OGC: POINT Z (1 2 3)</p>
                <p>EWKT: POINT (1 2 3)</p>
              </li>
              <li class="listitem">
                <p>For 3DM geometries the M qualifier is included:</p>
                <p>OGC: POINT M (1 2 3)</p>
                <p>EWKT: POINTM (1 2 3)</p>
              </li>
              <li class="listitem">
                <p>For 4D geometries the ZM qualifier is omitted:</p>
                <p>OGC: POINT ZM (1 2 3 4)</p>
                <p>EWKT: POINT (1 2 3 4)</p>
              </li>
            </ul>
          </div>
          <p>EWKT avoids over-specifying dimensionality
        and the inconsistencies that can occur with the OGC/ISO format, such as:
        </p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>POINT ZM (1 1)</p>
              </li>
              <li class="listitem">
                <p>POINT ZM (1 1 1)</p>
              </li>
              <li class="listitem">
                <p>POINT (1 1 1 1)</p>
              </li>
            </ul>
          </div>
          <div class="caution">
            <table style="border: 0; ">
              <tr>
                <td style="text-align: center; vertical-align: top; width: 25px; " rowspan="2">
                  <img alt="[Caution]" src="../images/caution.png"/>
                </td>
                <th style="text-align: left; "/>
              </tr>
              <tr>
                <td style="text-align: left; vertical-align: top; ">
                  <p>PostGIS extended formats are currently a superset of the OGC ones,
            so that every valid OGC WKB/WKT is also valid EWKB/EWKT.
			However, this might vary in the future,
            if the OGC extends a format in a way that conflicts with the PosGIS definition.
            Thus you SHOULD NOT rely on this compatibility!</p>
                </td>
              </tr>
            </table>
          </div>
          <p>Examples of the EWKT text representation of spatial objects are:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>POINT(0 0 0) -- XYZ</p>
              </li>
              <li class="listitem">
                <p>SRID=32632;POINT(0 0) -- XY with SRID</p>
              </li>
              <li class="listitem">
                <p>POINTM(0 0 0) -- XYM</p>
              </li>
              <li class="listitem">
                <p>POINT(0 0 0 0) -- XYZM</p>
              </li>
              <li class="listitem">
                <p>SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID</p>
              </li>
              <li class="listitem">
                <p>MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4
		  1))</p>
              </li>
              <li class="listitem">
                <p>POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2
		  0,1 1 0))</p>
              </li>
              <li class="listitem">
                <p>MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2
		  0,1 2 0,1 1 0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))</p>
              </li>
              <li class="listitem">
                <p>GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )</p>
              </li>
              <li class="listitem">
                <p>MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )</p>
              </li>
              <li class="listitem">
                <p>POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),
((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),  ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),
((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)),  ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )</p>
              </li>
              <li class="listitem">
                <p>TRIANGLE ((0 0, 0 10, 10 0, 0 0))</p>
              </li>
              <li class="listitem">
                <p>TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)),
		  ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )</p>
              </li>
            </ul>
          </div>
          <p>Input and output using these formats is available using the following functions:</p>
          <pre class="programlisting">bytea EWKB = ST_AsEWKB(geometry);
text EWKT = ST_AsEWKT(geometry);
geometry = ST_GeomFromEWKB(bytea EWKB);
geometry = ST_GeomFromEWKT(text EWKT);</pre>
          <p>For example, a statement to create and insert a PostGIS spatial object using EWKT is:</p>
          <pre class="programlisting">INSERT INTO geotable ( geom, name )
  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )</pre>
        </section>
      </section>
      <section class="section" id="PostGIS_Geography">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">4.3. Geography Data Type</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <ul class="toc">
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#Create_Geography_Tables">4.3.1. Creating Geography Tables</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#Use_Geography_Tables">4.3.2. Using Geography Tables</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#PostGIS_GeographyVSGeometry">4.3.3. When to use the Geography data type</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#PostGIS_Geography_AdvancedFAQ">4.3.4. Geography Advanced FAQ</a>
              </span>
            </li>
          </ul>
        </div>
        <p>The PostGIS <code class="varname">geography</code> data type provides native support for spatial features represented on "geographic" coordinates (sometimes called "geodetic" coordinates, or "lat/lon", or "lon/lat"). Geographic coordinates are spherical coordinates expressed in angular units (degrees). </p>
        <p>The basis for the PostGIS geometry data type is a plane.
      The shortest path between two points on the plane is a straight line.
      That means functions on geometries (areas, distances, lengths, intersections, etc)
      are calculated using straight line vectors and cartesian mathematics.
      This makes them simpler to implement and faster to execute,
      but also makes them inaccurate for data on the spheroidal surface of the earth.
      </p>
        <p>The PostGIS geography data type is based on a spherical model.
      The shortest path between two points on the sphere is a great circle arc.
      Functions on geographies (areas, distances, lengths, intersections, etc) are calculated using arcs on the sphere.
      By taking the spheroidal shape of the world into account, the functions provide more accurate results.</p>
        <p>Because the underlying mathematics is more complicated, there are fewer functions defined for the geography type than for the geometry type.
      Over time, as new algorithms are added the capabilities of the geography type will expand.
      As a workaround one can convert back and forth between geometry and geography types.</p>
        <p>Like the geometry data type, geography data is associated
      with a spatial reference system via a spatial reference system identifier (SRID).
        Any geodetic (long/lat based) spatial reference system defined in the <code class="varname">spatial_ref_sys</code> table can be used.
        (Prior to PostGIS 2.2, the geography type supported only WGS 84 geodetic (SRID:4326)).
		You can add your own custom geodetic spatial reference system as described in <a class="xref" href="using_postgis_dbmanagement.html#user-spatial-ref-sys" title="4.5.2. User-Defined Spatial Reference Systems">Section 4.5.2, “User-Defined Spatial Reference Systems”</a>.</p>
        <p>For all spatial reference systems the units returned by measurement functions
      (e.g. <a class="xref" href="ST_Distance.html" title="ST_Distance">ST_Distance</a>, <a class="xref" href="ST_Length.html" title="ST_Length">ST_Length</a>, <a class="xref" href="ST_Perimeter.html" title="ST_Perimeter">ST_Perimeter</a>, <a class="xref" href="ST_Area.html" title="ST_Area">ST_Area</a>)
      and for the distance argument of <a class="xref" href="ST_DWithin.html" title="ST_DWithin">ST_DWithin</a> are in meters.</p>
        <section class="section" id="Create_Geography_Tables">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.3.1. Creating Geography Tables</h3>
              </div>
            </div>
          </div>
          <p>You can create a table to store geography data using the
        <a class="link" href="https://www.postgresql.org/docs/current/sql-createtable.html" target="_top">CREATE TABLE</a>
        SQL statement with a column of type <code class="varname">geography</code>.
        The following example creates a table with a geography column storing 2D LineStrings
        in the WGS84 geodetic coordinate system (SRID 4326):</p>
          <pre class="programlisting">CREATE TABLE global_points (
    id SERIAL PRIMARY KEY,
    name VARCHAR(64),
    location geography(POINT,4326)
  );</pre>
          <p>The geography type supports two optional type modifiers:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>the spatial type modifier restricts the kind of shapes and dimensions allowed in the column.
		Values allowed for the spatial type are: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION.
        The geography type does not support curves, TINS, or POLYHEDRALSURFACEs.
        The modifier supports coordinate dimensionality restrictions by adding suffixes: Z, M and ZM.
        For example, a modifier of 'LINESTRINGM' only allows linestrings with three dimensions, and treats the third dimension as a measure.
		Similarly, 'POINTZM' requires four dimensional (XYZM) data.
        </p>
              </li>
              <li class="listitem">
                <p>the SRID modifier restricts the spatial reference system SRID to a particular number.
        If omitted, the SRID defaults to 4326 (WGS84 geodetic), and all calculations are performed using WGS84.
        </p>
              </li>
            </ul>
          </div>
          <p/>
          <p>Examples of creating tables with geography columns:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>Create a table with 2D POINT geography with the default SRID 4326 (WGS84 long/lat):</p>
                <pre class="programlisting">CREATE TABLE ptgeogwgs(gid serial PRIMARY KEY, geog geography(POINT) );</pre>
              </li>
              <li class="listitem">
                <p>Create a table with 2D POINT geography in NAD83 longlat:</p>
                <pre class="programlisting">CREATE TABLE ptgeognad83(gid serial PRIMARY KEY, geog geography(POINT,4269) );</pre>
              </li>
              <li class="listitem">
                <p>Create a table with 3D (XYZ) POINTs and an explicit SRID of 4326:</p>
                <pre class="programlisting">CREATE TABLE ptzgeogwgs84(gid serial PRIMARY KEY, geog geography(POINTZ,4326) );</pre>
              </li>
              <li class="listitem">
                <p>Create a table with 2D LINESTRING geography with the default SRID 4326:</p>
                <pre class="programlisting">CREATE TABLE lgeog(gid serial PRIMARY KEY, geog geography(LINESTRING) );</pre>
              </li>
              <li class="listitem">
                <p>Create a table with 2D POLYGON geography with the SRID 4267 (NAD 1927 long lat):</p>
                <pre class="programlisting">CREATE TABLE lgeognad27(gid serial PRIMARY KEY, geog geography(POLYGON,4267) );</pre>
              </li>
            </ul>
          </div>
          <p>Geography fields are registered in the <code class="varname">geography_columns</code> system view.
		You can query the <code class="varname">geography_columns</code> view and see that the table is listed:</p>
          <pre class="programlisting">
SELECT * FROM geography_columns;</pre>
          <p>Creating a spatial index works the same as for geometry columns.
	PostGIS will note that the column type is GEOGRAPHY and create an appropriate sphere-based index instead of the usual planar index used for GEOMETRY.</p>
          <pre class="programlisting">-- Index the test table with a spherical index
CREATE INDEX global_points_gix ON global_points USING GIST ( location );</pre>
        </section>
        <section class="section" id="Use_Geography_Tables">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.3.2. Using Geography Tables</h3>
              </div>
            </div>
          </div>
          <p>You can insert data into geography tables in the same way as geometry.
Geometry data will autocast to the geography type if it has SRID 4326.
The <a class="link" href="using_postgis_dbmanagement.html#EWKB_EWKT" title="4.2.1. PostGIS EWKB and EWKT">EWKT and EWKB</a> formats can also be used
to specify geography values.</p>
          <pre class="programlisting">-- Add some data into the test table
INSERT INTO global_points (name, location) VALUES ('Town', 'SRID=4326;POINT(-110 30)');
INSERT INTO global_points (name, location) VALUES ('Forest', 'SRID=4326;POINT(-109 29)');
INSERT INTO global_points (name, location) VALUES ('London', 'SRID=4326;POINT(0 49)');
</pre>
          <p>Any geodetic (long/lat) spatial reference system listed in
<code class="varname">spatial_ref_sys</code> table may be specified as a geography SRID.
Non-geodetic coordinate systems raise an error if used.
</p>
          <pre class="programlisting">-- NAD 83 lon/lat
SELECT 'SRID=4269;POINT(-123 34)'::geography;
                    geography
----------------------------------------------------
 0101000020AD1000000000000000C05EC00000000000004140
</pre>
          <pre class="programlisting">-- NAD27 lon/lat
SELECT 'SRID=4267;POINT(-123 34)'::geography;
                    geography
----------------------------------------------------
 0101000020AB1000000000000000C05EC00000000000004140
</pre>
          <pre class="programlisting">-- NAD83 UTM zone meters - gives an error since it is a meter-based planar projection
SELECT 'SRID=26910;POINT(-123 34)'::geography;

ERROR:  Only lon/lat coordinate systems are supported in geography.
</pre>
          <p>Query and measurement functions use units of meters. So distance parameters should be expressed in meters, and return values should be expected in meters (or square meters for areas).</p>
          <pre class="programlisting">-- A distance query using a 1000km tolerance
SELECT name FROM global_points WHERE ST_DWithin(location, 'SRID=4326;POINT(-110 29)'::geography, 1000000);</pre>
          <p>You can see the power of geography in action by calculating how close a plane flying
a great circle route from Seattle to London (LINESTRING(-122.33 47.606, 0.0 51.5))
comes to Reykjavik (POINT(-21.96 64.15))
(<a class="link" href="http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR" target="_top">map the route</a>).
</p>
          <p>The geography type calculates the true shortest distance of 122.235 km over the sphere
between Reykjavik and the great circle flight path between Seattle and London.</p>
          <pre class="programlisting">-- Distance calculation using GEOGRAPHY
SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, 'POINT(-21.96 64.15)'::geography);
   st_distance
-----------------
 122235.23815667</pre>
          <p>
The geometry type calculates a meaningless cartesian distance between Reykjavik
and the straight line path from Seattle to London plotted on a flat map of the world.
The nominal units of the result is "degrees",
but the result doesn't correspond to any true angular difference between the points,
so even calling them "degrees" is inaccurate.</p>
          <pre class="programlisting">-- Distance calculation using GEOMETRY
SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, 'POINT(-21.96 64.15)'::geometry);
      st_distance
--------------------
 13.342271221453624
</pre>
        </section>
        <section class="section" id="PostGIS_GeographyVSGeometry">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.3.3. When to use the Geography data type</h3>
              </div>
            </div>
          </div>
          <p>The geography data type allows you to store data in longitude/latitude coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY than there are on GEOMETRY; those functions that are defined take more CPU time to execute.</p>
          <p>The data type you choose should be determined by the expected working area of the application you are building. Will your data span the globe or a large continental area, or is it local to a state, county or municipality? </p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>If your data is contained in a small area, you might find that choosing an appropriate projection and using GEOMETRY is the best solution, in terms of performance and functionality available.</p>
              </li>
              <li class="listitem">
                <p>If your data is global or covers a continental region, you may find that GEOGRAPHY allows you to build a system without having to worry about projection details.
				You store your data in longitude/latitude, and use the functions that have been defined on GEOGRAPHY.</p>
              </li>
              <li class="listitem">
                <p>If you don't understand projections, and you don't want to learn about them, and you're prepared to accept the limitations in functionality available in GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY.
		Simply load your data up as longitude/latitude and go from there.</p>
              </li>
            </ul>
          </div>
          <p>Refer to <a class="xref" href="PostGIS_Special_Functions_Index.html#PostGIS_TypeFunctionMatrix" title="13.11. PostGIS Function Support Matrix">Section 13.11, “PostGIS Function Support Matrix”</a> for compare between
		what is supported for Geography vs. Geometry.  For a brief listing and description of Geography functions, refer to
		<a class="xref" href="PostGIS_Special_Functions_Index.html#PostGIS_GeographyFunctions" title="13.4. PostGIS Geography Support Functions">Section 13.4, “PostGIS Geography Support Functions”</a>
		</p>
        </section>
        <section class="section" id="PostGIS_Geography_AdvancedFAQ">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.3.4. Geography Advanced FAQ</h3>
              </div>
            </div>
          </div>
          <div class="qandaset" id="idm1610">
            <ul>
              <li>
                <a href="using_postgis_dbmanagement.html#idm1611">4.3.4.1. Do you calculate on the sphere or the spheroid?</a>
              </li>
              <li>
                <a href="using_postgis_dbmanagement.html#idm1617">4.3.4.2. What about the date-line and the poles?</a>
              </li>
              <li>
                <a href="using_postgis_dbmanagement.html#idm1622">4.3.4.3. What is the longest arc you can process?</a>
              </li>
              <li>
                <a href="using_postgis_dbmanagement.html#idm1627">4.3.4.4. Why is it so slow to calculate the area of Europe / Russia / insert big geographic region here ?</a>
              </li>
            </ul>
            <table style="border: 0; width: 100%;">
              <colgroup>
                <col style="text-align: left; width: 1%; "/>
                <col/>
              </colgroup>
              <tbody>
                <tr class="question" id="idm1611">
                  <td style="text-align: left; vertical-align: top; " id="idm1612">
                    <p>
                      <strong>4.3.4.1.</strong>
                    </p>
                  </td>
                  <td style="text-align: left; vertical-align: top; ">
                    <p>Do you calculate on the sphere or the spheroid?</p>
                  </td>
                </tr>
                <tr class="answer">
                  <td style="text-align: left; vertical-align: top; "/>
                  <td style="text-align: left; vertical-align: top; ">
                    <p> By default, all distance and area calculations are done on the spheroid. You should find that the results of calculations in local areas match up will with local planar results in good local projections.
					Over larger areas, the spheroidal calculations will be more accurate than any calculation done on a projected plane.
					</p>
                    <p>All the geography functions have the option of using a sphere calculation, by setting a final boolean parameter to 'FALSE'. This will somewhat speed up calculations, particularly for cases where the geometries are very simple.</p>
                  </td>
                </tr>
                <tr class="question" id="idm1617">
                  <td style="text-align: left; vertical-align: top; " id="idm1618">
                    <p>
                      <strong>4.3.4.2.</strong>
                    </p>
                  </td>
                  <td style="text-align: left; vertical-align: top; ">
                    <p>What about the date-line and the poles?</p>
                  </td>
                </tr>
                <tr class="answer">
                  <td style="text-align: left; vertical-align: top; "/>
                  <td style="text-align: left; vertical-align: top; ">
                    <p> All the calculations have no conception of date-line or poles, the coordinates are spherical (longitude/latitude)
					so a shape that crosses the dateline is, from a calculation point of view, no different from any other shape.
					</p>
                  </td>
                </tr>
                <tr class="question" id="idm1622">
                  <td style="text-align: left; vertical-align: top; " id="idm1623">
                    <p>
                      <strong>4.3.4.3.</strong>
                    </p>
                  </td>
                  <td style="text-align: left; vertical-align: top; ">
                    <p>What is the longest arc you can process?</p>
                  </td>
                </tr>
                <tr class="answer">
                  <td style="text-align: left; vertical-align: top; "/>
                  <td style="text-align: left; vertical-align: top; ">
                    <p>We use great circle arcs as the "interpolation line" between two points. That means any two points are actually joined up two ways, depending on which direction you travel along the great circle. All our code assumes that the points are joined by the *shorter* of the two paths along the great circle.
					As a consequence, shapes that have arcs of more than 180 degrees will not be correctly modelled.</p>
                  </td>
                </tr>
                <tr class="question" id="idm1627">
                  <td style="text-align: left; vertical-align: top; " id="idm1628">
                    <p>
                      <strong>4.3.4.4.</strong>
                    </p>
                  </td>
                  <td style="text-align: left; vertical-align: top; ">
                    <p>Why is it so slow to calculate the area of Europe / Russia / insert big geographic region here ?</p>
                  </td>
                </tr>
                <tr class="answer">
                  <td style="text-align: left; vertical-align: top; "/>
                  <td style="text-align: left; vertical-align: top; ">
                    <p>Because the polygon is so darned huge! Big areas are bad for two reasons: their bounds are huge,
						so the index tends to pull the feature no matter what query you run; the number of vertices is huge,
						and tests (distance, containment) have to traverse the vertex list at least once and sometimes N times
						(with N being the number of vertices in the other candidate feature).
					</p>
                    <p>As with GEOMETRY, we recommend that when you have very large polygons, but are doing queries in small areas, you "denormalize" your geometric data into smaller chunks so that the index can effectively subquery parts of the object and so queries don't have to pull out the whole object every time. Please consult <a class="xref" href="ST_Subdivide.html" title="ST_Subdivide">ST_Subdivide</a> function documentation.
					Just because you *can* store all of Europe in one polygon doesn't mean you *should*.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
      </section>
      <section class="section" id="OGC_Validity">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">4.4. Geometry Validation</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <ul class="toc">
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#Simple_Geometry">4.4.1. Simple Geometry</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#Valid_Geometry">4.4.2. Valid Geometry</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#Managing_Validity">4.4.3. Managing Validity</a>
              </span>
            </li>
          </ul>
        </div>
        <p>PostGIS is compliant with the Open Geospatial Consortium’s (OGC)
	  Simple Features specification.
      That standard defines the concepts of geometry being
      <span class="emphasis"><em>simple</em></span> and <span class="emphasis"><em>valid</em></span>.
      These definitions allow the Simple Features geometry model
      to represent spatial objects in a consistent and unambiguous way
      that supports efficient computation.
      (Note: the OGC SF and SQL/MM have the same definitions for simple and valid.)
        </p>
        <section class="section" id="Simple_Geometry">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.4.1. Simple Geometry</h3>
              </div>
            </div>
          </div>
          <p>A <span class="emphasis"><em>simple</em></span>
	  geometry is one that has no anomalous geometric points, such as self
	  intersection or self tangency.
	  </p>
          <p>A <code class="varname">POINT</code> is inherently <span class="emphasis"><em>simple</em></span>
	  as a 0-dimensional geometry object.</p>
          <p><code class="varname">MULTIPOINT</code>s are <span class="emphasis"><em>simple</em></span> if
	  no two coordinates (<code class="varname">POINT</code>s) are equal (have identical
	  coordinate values).</p>
          <p>A <code class="varname">LINESTRING</code> is <span class="emphasis"><em>simple</em></span> if
	  it does not pass through the same point twice, except for the endpoints.
      If the endpoints of a simple LineString are identical it is called <span class="emphasis"><em>closed</em></span>
      and referred to as a Linear Ring.</p>
          <div class="informaltable">
            <table style="border: none;">
              <colgroup>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <p>
                      <span class="emphasis">
                        <em>
                <span class="bold"><strong>(a)</strong></span> and
				<span class="bold"><strong>(c)</strong></span> are simple	<code class="varname">LINESTRING</code>s.
                <span class="bold"><strong>(b)</strong></span> and <span class="bold"><strong>(d)</strong></span> are not simple.
                <span class="bold"><strong>(c)</strong></span> is a closed Linear Ring.
                </em>
                      </span>
                    </p>
                  </td>
                </tr>
              </tbody>
            </table>
            <table style="border: none;">
              <colgroup>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td style="text-align: center; border-right: 1px solid ; border-bottom: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_issimple01.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(a)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; border-bottom: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_issimple02.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(b)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                </tr>
                <tr>
                  <td style="text-align: center; border-right: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_issimple03.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(c)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_issimple04.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(d)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>A <code class="varname">MULTILINESTRING</code> is <span class="emphasis"><em>simple</em></span>
	  only if all of its elements are simple and the only intersection between
	  any two elements occurs at points that are on the
	  boundaries of both elements.  </p>
          <div class="informaltable">
            <table style="border: none;">
              <colgroup>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <p>
                      <span class="emphasis">
                        <em>
                <span class="bold"><strong>(e)</strong></span> and
				<span class="bold"><strong>(f)</strong></span> are simple
				<code class="varname">MULTILINESTRING</code>s.
                <span class="bold"><strong>(g)</strong></span> is not simple.
                </em>
                      </span>
                    </p>
                  </td>
                </tr>
              </tbody>
            </table>
            <table style="border: none;">
              <colgroup>
                <col/>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td style="text-align: center; border-right: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_issimple05.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(e)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; border-right: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_issimple06.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(f)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_issimple07.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(g)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p><code class="varname">POLYGON</code>s are formed from linear rings, so
    valid polygonal geometry is always <span class="emphasis"><em>simple</em></span>.</p>
          <p>To test if a geometry is simple
	use the <a class="xref" href="ST_IsSimple.html" title="ST_IsSimple">ST_IsSimple</a> function:</p>
          <pre class="programlisting">
SELECT
   ST_IsSimple('LINESTRING(0 0, 100 100)') AS straight,
   ST_IsSimple('LINESTRING(0 0, 100 100, 100 0, 0 100)') AS crossing;

 straight | crossing
----------+----------
 t        | f
</pre>
          <p>Generally, PostGIS functions do not require geometric arguments to be simple.
	Simplicity is primarily used as a basis for defining geometric validity.
    It is also a requirement for some kinds of spatial data models
    (for example, linear networks often disallow lines that cross).
    Multipoint and linear geometry can be made simple using <a class="xref" href="ST_UnaryUnion.html" title="ST_UnaryUnion">ST_UnaryUnion</a>.
    </p>
        </section>
        <section class="section" id="Valid_Geometry">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.4.2. Valid Geometry</h3>
              </div>
            </div>
          </div>
          <p>Geometry validity primarily applies to 2-dimensional
        geometries (<code class="varname">POLYGON</code>s and <code class="varname">MULTIPOLYGON</code>s) .
        Validity is defined by rules that allow polygonal geometry
        to model planar areas unambiguously.
        </p>
          <p>A <code class="varname">POLYGON</code> is <span class="emphasis"><em>valid</em></span> if:
      </p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
                <p>
        the polygon boundary rings (the exterior shell ring and interior hole rings)
        are <span class="emphasis"><em>simple</em></span> (do not cross or self-touch).
        Because of this a polygon cannot have cut lines, spikes or loops.
        This implies that polygon holes must be represented as interior rings,
        rather than by the exterior ring self-touching (a so-called "inverted hole").
        </p>
              </li>
              <li class="listitem">
                <p>
        boundary rings do not cross
        </p>
              </li>
              <li class="listitem">
                <p>
        boundary rings may touch at points but only as a tangent (i.e. not in a line)
        </p>
              </li>
              <li class="listitem">
                <p>
        interior rings are contained in the exterior ring
        </p>
              </li>
              <li class="listitem">
                <p>
        the polygon interior is simply connected
        (i.e. the rings must not touch in a way that splits the polygon into more than one part)
        </p>
              </li>
            </ol>
          </div>
          <div class="informaltable">
            <table style="border: none;">
              <colgroup>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <p>
                      <span class="emphasis">
                        <em>
                <span class="bold"><strong>(h)</strong></span> and
				<span class="bold"><strong>(i)</strong></span> are valid <code class="varname">POLYGON</code>s.
                <span class="bold"><strong>(j-m)</strong></span> are invalid.
				<span class="bold"><strong>(j)</strong></span>
				can be represented as a valid <code class="varname">MULTIPOLYGON</code>.
				</em>
                      </span>
                    </p>
                  </td>
                </tr>
              </tbody>
            </table>
            <table style="border: none;">
              <colgroup>
                <col/>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td style="text-align: center; border-right: 1px solid ; border-bottom: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_isvalid01.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(h)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; border-right: 1px solid ; border-bottom: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_isvalid02.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(i)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; border-bottom: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_isvalid03.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(j)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                </tr>
                <tr>
                  <td style="text-align: center; border-right: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_isvalid04.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(k)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; border-right: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_isvalid05.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(l)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_isvalid06.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(m)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>A <code class="varname">MULTIPOLYGON</code> is <span class="emphasis"><em>valid</em></span> if:
	  </p>
          <div class="orderedlist">
            <ol class="orderedlist" type="1">
              <li class="listitem">
                <p>
        its element <code class="varname">POLYGON</code>s are valid
        </p>
              </li>
              <li class="listitem">
                <p>
        elements do not overlap (i.e. their interiors must not intersect)
        </p>
              </li>
              <li class="listitem">
                <p>
        elements touch only at points (i.e. not along a line)
        </p>
              </li>
            </ol>
          </div>
          <div class="informaltable">
            <table style="border: none;">
              <colgroup>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
                    <p>
                      <span class="emphasis">
                        <em>
                <span class="bold"><strong>(n)</strong></span> is a valid <code class="varname">MULTIPOLYGON</code>.
				<span class="bold"><strong>(o)</strong></span> and <span class="bold"><strong>(p)</strong></span> are invalid.
                </em>
                      </span>
                    </p>
                  </td>
                </tr>
              </tbody>
            </table>
            <table style="border: none;">
              <colgroup>
                <col/>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td style="text-align: center; border-right: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_isvalid09.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(n)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; border-right: 1px solid ; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_isvalid07.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(o)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td style="text-align: center; ">
                    <div class="informalfigure">
                      <div class="mediaobject">
                        <img src="../images/st_isvalid08.png"/>
                        <div class="caption">
                          <p>
                            <span class="bold">
                              <strong>(p)</strong>
                            </span>
                          </p>
                        </div>
                      </div>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>These rules mean that valid polygonal geometry is also <span class="emphasis"><em>simple</em></span>.
       </p>
          <p>For linear geometry the only validity rule is that <code class="varname">LINESTRING</code>s must
    have at least two points and have non-zero length
    (or equivalently, have at least two distinct points.)
    Note that non-simple (self-intersecting) lines are valid.
    </p>
          <pre class="programlisting">
SELECT
   ST_IsValid('LINESTRING(0 0, 1 1)') AS len_nonzero,
   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)') AS len_zero,
   ST_IsValid('LINESTRING(10 10, 150 150, 180 50, 20 130)') AS self_int;

 len_nonzero | len_zero | self_int
-------------+----------+----------
 t           | f        | t
</pre>
          <p><code class="varname">POINT</code> and <code class="varname">MULTIPOINT</code> geometries
    have no validity rules.
    </p>
        </section>
        <section class="section" id="Managing_Validity">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.4.3. Managing Validity</h3>
              </div>
            </div>
          </div>
          <p>PostGIS allows creating and storing both valid and invalid Geometry.
        This allows invalid geometry to be detected and flagged or fixed.
        There are also situations where the OGC validity rules are stricter than desired
        (examples of this are zero-length linestrings and polygons with inverted holes.)
        </p>
          <p>Many of the functions provided by PostGIS rely on the
	  assumption that geometry arguments are valid.
      For example, it does not make sense to calculate the area of
	  a polygon that has a hole defined outside of the polygon, or to construct
	  a polygon from a non-simple boundary line.
      Assuming valid geometric inputs allows functions to operate more efficiently,
      since they do not need to check for topological correctness.
      (Notable exceptions are that zero-length lines
      and polygons with inversions are generally handled correctly.)
      Also, most PostGIS functions produce valid geometry output if the inputs are valid.
      This allows PostGIS functions to be chained together safely.
      </p>
          <p>If you encounter unexpected error messages when calling PostGIS functions
      (such as "GEOS Intersection() threw an error!"),
      you should first confirm that the function arguments are valid.
      If they are not, then consider using one of the techniques below to ensure
      the data you are processing is valid.
        </p>
          <div class="note">
            <table style="border: 0; ">
              <tr>
                <td style="text-align: center; vertical-align: top; width: 25px; " rowspan="2">
                  <img alt="[Note]" src="../images/note.png"/>
                </td>
                <th style="text-align: left; "/>
              </tr>
              <tr>
                <td style="text-align: left; vertical-align: top; ">
                  <p>
      If a function reports an error with valid inputs,
      then you may have found an error in either PostGIS or one of
		the libraries it uses, and you should report this to the PostGIS project.
		The same is true if a PostGIS function returns an invalid geometry for
		valid input.</p>
                </td>
              </tr>
            </table>
          </div>
          <p>To test if a geometry is valid use the
	  <a class="xref" href="ST_IsValid.html" title="ST_IsValid">ST_IsValid</a> function:
      </p>
          <pre class="programlisting">
SELECT ST_IsValid('POLYGON ((20 180, 180 180, 180 20, 20 20, 20 180))');
-----------------
 t
</pre>
          <p>Information about the nature and location of an geometry invalidity are provided by
	  the <a class="xref" href="ST_IsValidDetail.html" title="ST_IsValidDetail">ST_IsValidDetail</a> function:
      </p>
          <pre class="programlisting">
SELECT valid, reason, ST_AsText(location) AS location
    FROM ST_IsValidDetail('POLYGON ((20 20, 120 190, 50 190, 170 50, 20 20))') AS t;

 valid |      reason       |                  location
-------+-------------------+---------------------------------------------
 f     | Self-intersection | POINT(91.51162790697674 141.56976744186045)
</pre>
          <p>In some situations it is desirable to correct invalid geometry automatically.
	  Use the <a class="xref" href="ST_MakeValid.html" title="ST_MakeValid">ST_MakeValid</a> function to do this.
      (<code class="code">ST_MakeValid</code> is a case of a spatial function that <span class="emphasis"><em>does</em></span> allow invalid input!)
      </p>
          <p>By default, PostGIS does not check for validity when loading geometry,
	  because validity testing can take a lot of CPU time for complex
	  geometries. If you do not trust your data sources,
	  you can enforce a validity check on your tables by adding a check
	  constraint:</p>
          <pre class="programlisting">ALTER TABLE mytable
  ADD CONSTRAINT geometry_valid_check
	CHECK (ST_IsValid(geom));</pre>
        </section>
      </section>
      <section class="section" id="spatial_ref_sys">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">4.5. Spatial Reference Systems</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <ul class="toc">
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#spatial_ref_sys_table">4.5.1. SPATIAL_REF_SYS Table</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#user-spatial-ref-sys">4.5.2. User-Defined Spatial Reference Systems</a>
              </span>
            </li>
          </ul>
        </div>
        <p>A <a class="link" href="https://en.wikipedia.org/wiki/Spatial_reference_system" target="_top">Spatial Reference System</a> (SRS)
    (also called a Coordinate Reference System (CRS))
    defines how geometry is referenced to locations on the Earth's surface.
    There are three types of SRS:
     </p>
        <div class="itemizedlist">
          <ul class="itemizedlist" style="list-style-type: disc; ">
            <li class="listitem">
              <p>A <span class="bold"><strong>geodetic</strong></span> SRS uses angular coordinates
            (longitude and latitude) which map directly to the surface of the earth.
            </p>
            </li>
            <li class="listitem">
              <p>A <span class="bold"><strong>projected</strong></span> SRS
            uses a mathematical projection transformation
            to "flatten" the surface of the spheroidal earth onto a plane.
            It assigns location coordinates in a way that allows direct measurement
            of quantities such as distance, area, and angle.
            The coordinate system is Cartesian, which means it has a defined origin point
            and two perpendicular axes (usually oriented North and East).
            Each projected SRS uses a stated length unit (usually metres or feet).
            A projected SRS may be limited in its area of applicability to avoid distortion
            and fit within the defined coordinate bounds.
            </p>
            </li>
            <li class="listitem">
              <p>A <span class="bold"><strong>local</strong></span> SRS
            is a Cartesian coordinate system which is not referenced to the earth's surface.
            In PostGIS this is specified by a SRID value of 0.
            </p>
            </li>
          </ul>
        </div>
        <p>
    There are many different spatial reference systems in use.
    Common SRSes are standardized in the
    European Petroleum Survey Group
    <a class="link" href="http://www.epsg.org/" target="_top">EPSG database</a>.
    For convenience PostGIS (and many other spatial systems) refers to SRS
    definitions using an integer identifier called a SRID.
    </p>
        <p>A geometry is associated with a Spatial Reference System by its SRID value,
    which is accessed by <a class="xref" href="ST_SRID.html" title="ST_SRID">ST_SRID</a>.
    The SRID for a geometry can be assigned using <a class="xref" href="ST_SetSRID.html" title="ST_SetSRID">ST_SetSRID</a>.
    Some geometry constructor functions allow supplying a SRID
    (such as <a class="xref" href="ST_Point.html" title="ST_Point">ST_Point</a>  and <a class="xref" href="ST_MakeEnvelope.html" title="ST_MakeEnvelope">ST_MakeEnvelope</a>).
    The <a class="link" href="using_postgis_dbmanagement.html#EWKB_EWKT" title="4.2.1. PostGIS EWKB and EWKT">EWKT</a> format supports SRIDs with the <code class="code">SRID=n;</code> prefix.
    </p>
        <p>
    Spatial functions processing pairs of geometries
    (such as <a class="link" href="reference.html#Overlay_Functions" title="7.13. Overlay Functions">overlay</a> and
    <a class="link" href="reference.html#Spatial_Relationships" title="7.11. Spatial Relationships">relationship</a> functions)
    require that the input geometries are in the same spatial reference system (have the same SRID).
    Geometry data can be transformed into a different spatial reference system using
    <a class="xref" href="ST_Transform.html" title="ST_Transform">ST_Transform</a> and <a class="xref" href="ST_TransformPipeline.html" title="ST_TransformPipeline">ST_TransformPipeline</a>.
    Geometry returned from functions has the same SRS as the input geometries.
    </p>
        <section class="section" id="spatial_ref_sys_table">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.5.1. SPATIAL_REF_SYS Table</h3>
              </div>
            </div>
          </div>
          <p>The <code class="varname">SPATIAL_REF_SYS</code> table used by PostGIS
    is an OGC-compliant database table that defines the available
	spatial reference systems.
	It holds the numeric SRIDs and textual descriptions of the coordinate systems.
    </p>
          <p>The <code class="varname">spatial_ref_sys</code> table definition is:</p>
          <pre class="programlisting">CREATE TABLE spatial_ref_sys (
  srid       INTEGER NOT NULL PRIMARY KEY,
  auth_name  VARCHAR(256),
  auth_srid  INTEGER,
  srtext     VARCHAR(2048),
  proj4text  VARCHAR(2048)
)</pre>
          <p>The columns are:</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
                  <code class="varname">srid</code>
                </span>
              </dt>
              <dd>
                <p>An integer code that uniquely identifies the <a class="link" href="http://en.wikipedia.org/wiki/SRID" target="_top">Spatial
			Reference System</a> (SRS) within the database.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="varname">auth_name</code>
                </span>
              </dt>
              <dd>
                <p>The name of the standard or standards body that is being
			cited for this reference system. For example, "EPSG" is a
			valid <code class="varname">auth_name</code>.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="varname">auth_srid</code>
                </span>
              </dt>
              <dd>
                <p>The ID of the Spatial Reference System as defined by the
			Authority cited in the <code class="varname">auth_name</code>. In the case
			of EPSG, this is the EPSG code.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="varname">srtext</code>
                </span>
              </dt>
              <dd>
                <p>The Well-Known Text representation of the Spatial Reference
			System. An example of a WKT SRS representation is:</p>
                <pre class="programlisting">PROJCS["NAD83 / UTM Zone 10N",
  GEOGCS["NAD83",
	DATUM["North_American_Datum_1983",
	  SPHEROID["GRS 1980",6378137,298.257222101]
	],
	PRIMEM["Greenwich",0],
	UNIT["degree",0.0174532925199433]
  ],
  PROJECTION["Transverse_Mercator"],
  PARAMETER["latitude_of_origin",0],
  PARAMETER["central_meridian",-123],
  PARAMETER["scale_factor",0.9996],
  PARAMETER["false_easting",500000],
  PARAMETER["false_northing",0],
  UNIT["metre",1]
]</pre>
                <p>For a discussion of SRS WKT, see the OGC standard <a class="link" href="http://docs.opengeospatial.org/is/12-063r5/12-063r5.html" target="_top">Well-known text representation of coordinate reference systems</a>.
            </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="varname">proj4text</code>
                </span>
              </dt>
              <dd>
                <p>PostGIS uses the PROJ library to provide coordinate
			transformation capabilities. The <code class="varname">proj4text</code>
			column contains the PROJ coordinate definition string for a
			particular SRID. For example:</p>
                <pre class="programlisting">+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m</pre>
                <p>For more information see the
            <a class="link" href="https://proj.org/" target="_top">PROJ web site</a>.
			The <code class="filename">spatial_ref_sys.sql</code> file contains both
			<code class="varname">srtext</code> and <code class="varname">proj4text</code>
			definitions for all EPSG projections.</p>
              </dd>
            </dl>
          </div>
          <p>When retrieving spatial reference system definitions for use in transformations,
    PostGIS uses fhe following strategy:
    </p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>If <code class="varname">auth_name</code> and <code class="varname">auth_srid</code>
            are present (non-NULL)
            use the PROJ SRS based on those entries (if one exists).
            </p>
              </li>
              <li class="listitem">
                <p>If <code class="varname">srtext</code> is present
            create a SRS using it, if possible.
            </p>
              </li>
              <li class="listitem">
                <p>If <code class="varname">proj4text</code> is present
            create a SRS using it, if possible.
            </p>
              </li>
            </ul>
          </div>
        </section>
        <section class="section" id="user-spatial-ref-sys">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.5.2. User-Defined Spatial Reference Systems</h3>
              </div>
            </div>
          </div>
          <p>The PostGIS <code class="varname">spatial_ref_sys</code> table contains over 3000 of
    the most common spatial reference system definitions that are handled by the
    <a class="link" href="https://proj.org" target="_top">PROJ</a> projection library.
    But there are many coordinate systems that it does not contain.
    You can add SRS definitions to the table if you have
    the required information about the spatial reference system.
    Or, you can define your own custom spatial reference system if you are familiar with PROJ constructs.
    Keep in mind that most spatial reference systems are regional
    and have no meaning when used outside of the bounds they were intended for.</p>
          <p>A resource for finding spatial reference systems not defined in the core set is <a class="link" href="http://spatialreference.org/" target="_top">http://spatialreference.org/</a></p>
          <p>Some commonly used spatial reference systems are:
            <a class="link" href="http://spatialreference.org/ref/epsg/4326/" target="_top">4326 - WGS 84 Long Lat</a>,
			<a class="link" href="http://spatialreference.org/ref/epsg/4269/" target="_top">4269 - NAD 83 Long Lat</a>,
			<a class="link" href="http://spatialreference.org/ref/epsg/3395/" target="_top">3395 - WGS 84 World Mercator</a>,
			<a class="link" href="http://spatialreference.org/ref/epsg/2163/" target="_top">2163 - US National Atlas Equal Area</a>,
        and the 60 WGS84 UTM zones.
		UTM zones are one of the most ideal for measurement, but only cover 6-degree regions.
        (To determine which UTM zone to use for your area of interest, see the <a class="link" href="http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctionsDistance" target="_top">utmzone PostGIS plpgsql helper function</a>.)
	</p>
          <p>
		US states use State Plane spatial reference systems (meter or feet based) - usually one or 2 exists per state.
        Most of the meter-based ones are in the core set, but many of the
		feet-based ones or ESRI-created ones will need to be copied from <a class="link" href="http://spatialreference.org" target="_top">spatialreference.org</a>.
	</p>
          <p>You can even define non-Earth-based coordinate systems,
    such as <a class="link" href="http://spatialreference.org/ref/iau2000/mars-2000/" target="_top">Mars 2000</a>
    This Mars coordinate system is non-planar (it's in degrees spheroidal),
    but you can use it with the <code class="varname">geography</code> type
    to obtain length and proximity measurements in meters instead of degrees.</p>
          <p>Here is an example of loading a custom coordinate system using
    an unassigned SRID and the PROJ definition for a US-centric Lambert Conformal projection:</p>
          <pre class="programlisting">
INSERT INTO spatial_ref_sys (srid, proj4text)
VALUES ( 990000,
  '+proj=lcc  +lon_0=-95 +lat_0=25 +lat_1=25 +lat_2=25 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs'
);
</pre>
        </section>
      </section>
      <section class="section" id="idm2036">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">4.6. Spatial Tables</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <ul class="toc">
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#Create_Spatial_Table">4.6.1. Creating a Spatial Table</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#geometry_columns">4.6.2. GEOMETRY_COLUMNS View</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#Manual_Register_Spatial_Column">4.6.3. Manually Registering Geometry Columns</a>
              </span>
            </li>
          </ul>
        </div>
        <section class="section" id="Create_Spatial_Table">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.6.1. Creating a Spatial Table</h3>
              </div>
            </div>
          </div>
          <p>You can create a table to store geometry data using the
        <a class="link" href="https://www.postgresql.org/docs/current/sql-createtable.html" target="_top">CREATE TABLE</a>
        SQL statement with a column of type <code class="varname">geometry</code>.
        The following example creates a table with a geometry column storing 2D (XY) LineStrings
        in the BC-Albers coordinate system (SRID 3005):</p>
          <pre class="programlisting">CREATE TABLE roads (
    id SERIAL PRIMARY KEY,
    name VARCHAR(64),
    geom geometry(LINESTRING,3005)
  );</pre>
          <p>The <code class="varname">geometry</code> type supports two optional <span class="bold"><strong>type modifiers</strong></span>:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>the <span class="bold"><strong>spatial type modifier</strong></span>
        restricts the kind of shapes and dimensions allowed in the column.
		The value can be any of the supported
        <a class="link" href="using_postgis_dbmanagement.html#RefObject" title="4.1. Spatial Data Model">geometry subtypes</a>
        (e.g. POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION, etc).
        The modifier supports coordinate dimensionality restrictions by adding suffixes: Z, M and ZM.
        For example, a modifier of 'LINESTRINGM' allows only linestrings with three dimensions, and treats the third dimension as a measure.
		Similarly, 'POINTZM' requires four dimensional (XYZM) data.
        </p>
              </li>
              <li class="listitem">
                <p>the <span class="bold"><strong>SRID modifier</strong></span> restricts the
        <a class="link" href="using_postgis_dbmanagement.html#spatial_ref_sys" title="4.5. Spatial Reference Systems">spatial reference system</a> SRID to a particular number.
        If omitted, the SRID defaults to 0.
        </p>
              </li>
            </ul>
          </div>
          <p/>
          <p>Examples of creating tables with geometry columns:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>Create a table holding any kind of geometry with the default SRID:</p>
                <pre class="programlisting">CREATE TABLE geoms(gid serial PRIMARY KEY, geom geometry );</pre>
              </li>
              <li class="listitem">
                <p>Create a table with 2D POINT geometry with the default SRID:</p>
                <pre class="programlisting">CREATE TABLE pts(gid serial PRIMARY KEY, geom geometry(POINT) );</pre>
              </li>
              <li class="listitem">
                <p>Create a table with 3D (XYZ) POINTs and an explicit SRID of 3005:</p>
                <pre class="programlisting">CREATE TABLE pts(gid serial PRIMARY KEY, geom geometry(POINTZ,3005) );</pre>
              </li>
              <li class="listitem">
                <p>Create a table with 4D (XYZM) LINESTRING geometry with the default SRID:</p>
                <pre class="programlisting">CREATE TABLE lines(gid serial PRIMARY KEY, geom geometry(LINESTRINGZM) );</pre>
              </li>
              <li class="listitem">
                <p>Create a table with 2D POLYGON geometry with the SRID 4267 (NAD 1927 long lat):</p>
                <pre class="programlisting">CREATE TABLE polys(gid serial PRIMARY KEY, geom geometry(POLYGON,4267) );</pre>
              </li>
            </ul>
          </div>
          <p>It is possible to have more than one geometry column in a table.
        This can be specified when the table is created, or a column can be added using the
        <a class="link" href="https://www.postgresql.org/docs/current/sql-altertable.html" target="_top">ALTER TABLE</a>
        SQL statement.
        This example adds a column that can hold 3D LineStrings:</p>
          <pre class="programlisting">ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);</pre>
        </section>
        <section class="section" id="geometry_columns">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.6.2. GEOMETRY_COLUMNS View</h3>
              </div>
            </div>
          </div>
          <p>The OGC <span class="emphasis"><em>Simple Features Specification for SQL</em></span> defines
      the <code class="varname">GEOMETRY_COLUMNS</code> metadata table to describe geometry table structure.
      In PostGIS <code class="varname">geometry_columns</code> is a view reading from database system catalog tables.
      This ensures that the spatial metadata information is always consistent with the currently defined tables and views.
	  The view structure is:</p>
          <pre class="programlisting">\d geometry_columns</pre>
          <pre class="screen">             View "public.geometry_columns"
      Column       |          Type          | Modifiers
-------------------+------------------------+-----------
 f_table_catalog   | character varying(256) |
 f_table_schema    | character varying(256) |
 f_table_name      | character varying(256) |
 f_geometry_column | character varying(256) |
 coord_dimension   | integer                |
 srid              | integer                |
 type              | character varying(30)  |</pre>
          <p>The columns are:</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
                  <code class="varname">f_table_catalog, f_table_schema, f_table_name</code>
                </span>
              </dt>
              <dd>
                <p>The fully qualified name of the feature table containing the
			geometry column. There is no PostgreSQL analogue of "catalog" so that
			column is left blank. For "schema" the PostgreSQL schema name is
			used (<code class="varname">public</code> is the default).</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="varname">f_geometry_column</code>
                </span>
              </dt>
              <dd>
                <p>The name of the geometry column in the feature table.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="varname">coord_dimension</code>
                </span>
              </dt>
              <dd>
                <p>The coordinate dimension (2, 3 or 4) of the column.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="varname">srid</code>
                </span>
              </dt>
              <dd>
                <p>The ID of the spatial reference system used for the
			coordinate geometry in this table. It is a foreign key reference
			to the <code class="varname">spatial_ref_sys</code> table
            (see <a class="xref" href="using_postgis_dbmanagement.html#spatial_ref_sys_table" title="4.5.1. SPATIAL_REF_SYS Table">Section 4.5.1, “SPATIAL_REF_SYS Table”</a>).</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="varname">type</code>
                </span>
              </dt>
              <dd>
                <p>The type of the spatial object. To restrict the spatial
			column to a single type, use one of: POINT, LINESTRING, POLYGON,
			MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION or
			corresponding XYM versions POINTM, LINESTRINGM, POLYGONM,
			MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, GEOMETRYCOLLECTIONM.
			For heterogeneous (mixed-type) collections, you can use "GEOMETRY"
			as the type.</p>
              </dd>
            </dl>
          </div>
        </section>
        <section class="section" id="Manual_Register_Spatial_Column">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.6.3. Manually Registering Geometry Columns</h3>
              </div>
            </div>
          </div>
          <p>Two of the cases where you may need this are the case of SQL Views and bulk inserts.  For bulk insert case, you can correct the registration in the geometry_columns table
		by constraining the column or doing an alter table.  For views, you could expose using a CAST operation.
		Note, if your column is typmod based, the creation process would register it correctly, so no need to do anything.
		Also views that have no spatial function applied to the geometry will register the same as the underlying table geometry column.</p>
          <pre class="programlisting">-- Lets say you have a view created like this
CREATE VIEW public.vwmytablemercator AS
	SELECT gid, ST_Transform(geom, 3395) As geom, f_name
	FROM public.mytable;

-- For it to register correctly
-- You need to cast the geometry
--
DROP VIEW public.vwmytablemercator;
CREATE VIEW  public.vwmytablemercator AS
	SELECT gid, ST_Transform(geom, 3395)::geometry(Geometry, 3395) As geom, f_name
	FROM public.mytable;

-- If you know the geometry type for sure is a 2D POLYGON then you could do
DROP VIEW public.vwmytablemercator;
CREATE VIEW  public.vwmytablemercator AS
	SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As geom, f_name
	FROM public.mytable;</pre>
          <pre class="programlisting">--Lets say you created a derivative table by doing a bulk insert
SELECT poi.gid, poi.geom, citybounds.city_name
INTO myschema.my_special_pois
FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);

-- Create 2D index on new table
CREATE INDEX idx_myschema_myspecialpois_geom_gist
  ON myschema.my_special_pois USING gist(geom);

-- If your points are 3D points or 3M points,
-- then you might want to create an nd index instead of a 2D index
CREATE INDEX my_special_pois_geom_gist_nd
	ON my_special_pois USING gist(geom gist_geometry_ops_nd);

-- To manually register this new table's geometry column in geometry_columns.
-- Note it will also change the underlying structure of the table to
-- to make the column typmod based.
SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);

-- If you are using PostGIS 2.0 and for whatever reason, you
-- you need the constraint based definition behavior
-- (such as case of inherited tables where all children do not have the same type and srid)
-- set optional use_typmod argument to false
SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, false); </pre>
          <p>Although the old-constraint based method is still supported, a constraint-based geometry column used directly
in a view, will not register correctly in geometry_columns, as will a typmod one.
In this example we define a column using typmod and another using constraints.</p>
          <pre class="programlisting">CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY, poi_name text, cat text, geom geometry(POINT,4326));
SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);</pre>
          <p>If we run in psql</p>
          <pre class="programlisting">\d pois_ny;</pre>
          <p>We observe they are defined differently -- one is typmod, one is constraint</p>
          <pre class="screen">                                  Table "public.pois_ny"
  Column   |         Type          |                       Modifiers

-----------+-----------------------+------------------------------------------------------
 gid       | integer               | not null default nextval('pois_ny_gid_seq'::regclass)
 poi_name  | text                  |
 cat       | character varying(20) |
 geom      | geometry(Point,4326)  |
 geom_2160 | geometry              |
Indexes:
    "pois_ny_pkey" PRIMARY KEY, btree (gid)
Check constraints:
    "enforce_dims_geom_2160" CHECK (st_ndims(geom_2160) = 2)
    "enforce_geotype_geom_2160" CHECK (geometrytype(geom_2160) = 'POINT'::text
        OR geom_2160 IS NULL)
    "enforce_srid_geom_2160" CHECK (st_srid(geom_2160) = 2160)</pre>
          <p>In geometry_columns, they both register correctly</p>
          <pre class="programlisting">SELECT f_table_name, f_geometry_column, srid, type
	FROM geometry_columns
	WHERE f_table_name = 'pois_ny';</pre>
          <pre class="screen">f_table_name | f_geometry_column | srid | type
-------------+-------------------+------+-------
pois_ny      | geom              | 4326 | POINT
pois_ny      | geom_2160         | 2160 | POINT</pre>
          <p>However -- if we were to create a view like this</p>
          <pre class="programlisting">CREATE VIEW vw_pois_ny_parks AS
SELECT *
  FROM pois_ny
  WHERE cat='park';

SELECT f_table_name, f_geometry_column, srid, type
	FROM geometry_columns
	WHERE f_table_name = 'vw_pois_ny_parks';</pre>
          <p>The typmod based geom view column registers correctly,
but the constraint based one does not.</p>
          <pre class="screen">   f_table_name   | f_geometry_column | srid |   type
------------------+-------------------+------+----------
 vw_pois_ny_parks | geom              | 4326 | POINT
 vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY</pre>
          <p>This may change in future versions of PostGIS, but for now
to force the constraint-based view column to register correctly, you need to do this:</p>
          <pre class="programlisting">DROP VIEW vw_pois_ny_parks;
CREATE VIEW vw_pois_ny_parks AS
SELECT gid, poi_name, cat,
  geom,
  geom_2160::geometry(POINT,2160) As geom_2160
  FROM pois_ny
  WHERE cat = 'park';
SELECT f_table_name, f_geometry_column, srid, type
	FROM geometry_columns
	WHERE f_table_name = 'vw_pois_ny_parks';</pre>
          <pre class="screen">   f_table_name   | f_geometry_column | srid | type
------------------+-------------------+------+-------
 vw_pois_ny_parks | geom              | 4326 | POINT
 vw_pois_ny_parks | geom_2160         | 2160 | POINT</pre>
        </section>
      </section>
      <section class="section" id="loading-data">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">4.7. Loading Spatial Data</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <ul class="toc">
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#load-data-sql">4.7.1. Using SQL to Load Data</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#shp2pgsql_usage">4.7.2. Using the Shapefile Loader</a>
              </span>
            </li>
          </ul>
        </div>
        <p>Once you have created a spatial table, you are ready to upload spatial
	data to the database. There are two built-in ways to get spatial data into a
	PostGIS/PostgreSQL database: using formatted SQL statements or using the
	Shapefile loader.</p>
        <section class="section" id="load-data-sql">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.7.1. Using SQL to Load Data</h3>
              </div>
            </div>
          </div>
          <p>If spatial data can be converted to a text representation (as either WKT or WKB), then using
	  SQL might be the easiest way to get data into PostGIS.
      Data can be bulk-loaded into PostGIS/PostgreSQL by loading a
	  text file of SQL <code class="code">INSERT</code> statements using the <code class="code">psql</code> SQL utility.</p>
          <p>A SQL load file (<code class="filename">roads.sql</code> for example)
	  might look like this:</p>
          <pre class="programlisting">BEGIN;
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (1,'LINESTRING(191232 243118,191108 243242)','Jeff Rd');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (2,'LINESTRING(189141 244158,189265 244817)','Geordie Rd');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (3,'LINESTRING(192783 228138,192612 229814)','Paul St');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (4,'LINESTRING(189412 252431,189631 259122)','Graeme Ave');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (5,'LINESTRING(190131 224148,190871 228134)','Phil Tce');
INSERT INTO roads (road_id, roads_geom, road_name)
  VALUES (6,'LINESTRING(198231 263418,198213 268322)','Dave Cres');
COMMIT;</pre>
          <p>The SQL file can be loaded into PostgreSQL using <code class="code">psql</code>:</p>
          <pre class="programlisting">psql -d [database] -f roads.sql</pre>
        </section>
        <section class="section" id="shp2pgsql_usage">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.7.2. Using the Shapefile Loader</h3>
              </div>
            </div>
          </div>
          <p>
    The <code class="filename">shp2pgsql</code> data loader converts Shapefiles into SQL suitable for
    insertion into a PostGIS/PostgreSQL database either in geometry or geography format.
    The loader has several operating modes selected by command line flags.
  </p>
          <p>There is also a <code class="filename">shp2pgsql-gui</code> graphical interface with most
	of the options as the command-line loader.
    This may be easier to use for one-off non-scripted loading or if you are new to PostGIS.
	It can also be configured as a plugin to PgAdminIII.
	</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">(c|a|d|p) These are mutually exclusive options:</span>
              </dt>
              <dd>
                <p>
          </p>
                <div class="variablelist">
                  <dl class="variablelist">
                    <dt>
                      <span class="term">
                        <code class="option">-c</code>
                      </span>
                    </dt>
                    <dd>
                      <p>
                  Creates a new table and populates it from the Shapefile. <span class="emphasis"><em>This is the
                  default mode.</em></span>
                </p>
                    </dd>
                    <dt>
                      <span class="term">
                        <code class="option">-a</code>
                      </span>
                    </dt>
                    <dd>
                      <p>
                  Appends data from the Shapefile into the database table. Note that to use this
                  option to load multiple files, the files must have the same attributes and same
                  data types.
                </p>
                    </dd>
                    <dt>
                      <span class="term">
                        <code class="option">-d</code>
                      </span>
                    </dt>
                    <dd>
                      <p>
                  Drops the database table before creating a new table with the data in the Shapefile.
                </p>
                    </dd>
                    <dt>
                      <span class="term">
                        <code class="option">-p</code>
                      </span>
                    </dt>
                    <dd>
                      <p>
                  Only produces the table creation SQL code, without adding any actual data. This
                  can be used if you need to completely separate the table creation and data loading
                  steps.
                </p>
                    </dd>
                  </dl>
                </div>
                <p>
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-?</code>
                </span>
              </dt>
              <dd>
                <p>
          Display help screen.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-D</code>
                </span>
              </dt>
              <dd>
                <p>
          Use the PostgreSQL "dump" format for the output data. This can be combined with -a, -c and
          -d. It is much faster to load than the default "insert" SQL format. Use this for very
          large data sets.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-s [&lt;FROM_SRID&gt;:]&lt;SRID&gt;</code>
                </span>
              </dt>
              <dd>
                <p>
          Creates and populates the geometry tables with the specified SRID.
          Optionally specifies that the input shapefile uses the given
          FROM_SRID, in which case the geometries will be reprojected to the
          target SRID.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-k</code>
                </span>
              </dt>
              <dd>
                <p>
          Keep identifiers' case (column, schema and attributes). Note that attributes in Shapefile
          are all UPPERCASE.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-i</code>
                </span>
              </dt>
              <dd>
                <p>
          Coerce all integers to standard 32-bit integers, do not create 64-bit bigints, even if the
          DBF header signature appears to warrant it.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-I</code>
                </span>
              </dt>
              <dd>
                <p>
          Create a GiST index on the geometry column.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-m</code>
                </span>
              </dt>
              <dd>
                <p>
          -m <code class="filename">a_file_name</code>  Specify a file containing a set of mappings of (long) column
     names to 10 character DBF column names. The content of the file is one or
     more lines of two names separated by white space and no trailing or
     leading space. For example:
         </p>
                <pre class="programlisting">COLUMNNAME DBFFIELD1
AVERYLONGCOLUMNNAME DBFFIELD2</pre>
                <p>
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-S</code>
                </span>
              </dt>
              <dd>
                <p>
          Generate simple geometries instead of MULTI geometries.  Will only succeed if
          all the geometries are actually single (I.E. a MULTIPOLYGON with a single shell, or
          or a MULTIPOINT with a single vertex).
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-t &lt;dimensionality&gt;</code>
                </span>
              </dt>
              <dd>
                <p>
          Force the output geometry to have the specified dimensionality. Use the following
          strings to indicate the dimensionality: 2D, 3DZ, 3DM, 4D.
        </p>
                <p>
	        If the input has fewer dimensions that specified, the output will have those dimensions filled
	        in with zeroes. If the input has more dimensions that specified, the unwanted dimensions will
	        be stripped.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-w</code>
                </span>
              </dt>
              <dd>
                <p>
          Output WKT format, instead of WKB.  Note that this can
          introduce coordinate drifts due to loss of precision.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-e</code>
                </span>
              </dt>
              <dd>
                <p>
          Execute each statement on its own, without using a transaction.
          This allows loading of the majority of good data when there are some bad
          geometries that generate errors.  Note that this cannot be used with the
          -D flag as the "dump" format always uses a transaction.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-W &lt;encoding&gt;</code>
                </span>
              </dt>
              <dd>
                <p>
          Specify encoding of the input data (dbf file). When used, all attributes of the dbf are
          converted from the specified encoding to UTF8. The resulting SQL output will contain a
          <code class="code">SET CLIENT_ENCODING to UTF8</code> command, so that the backend will be able to
          reconvert from UTF8 to whatever encoding the database is configured to use internally.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-N &lt;policy&gt;</code>
                </span>
              </dt>
              <dd>
                <p>
           NULL geometries handling policy (insert*,skip,abort)
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-n</code>
                </span>
              </dt>
              <dd>
                <p>
          -n  Only import DBF file.  If your data has no corresponding shapefile, it will automatically switch to this mode
	and load just the dbf.  So setting this flag is only needed if you have a full shapefile set, and you only want the attribute data and no geometry.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-G</code>
                </span>
              </dt>
              <dd>
                <p>
			Use geography type instead of geometry (requires lon/lat data) in WGS84 long lat (SRID=4326)
		</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-T &lt;tablespace&gt;</code>
                </span>
              </dt>
              <dd>
                <p>
          Specify the tablespace for the new table.  Indexes will still use the
          default tablespace unless the -X parameter is also used.  The PostgreSQL
          documentation has a good description on when to use custom tablespaces.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-X &lt;tablespace&gt;</code>
                </span>
              </dt>
              <dd>
                <p>
          Specify the tablespace for the new table's indexes.  This applies to
          the primary key index, and the GIST spatial index if -I is also used.
        </p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-Z</code>
                </span>
              </dt>
              <dd>
                <p>
          When used, this flag will prevent the generation of <code class="code">ANALYZE</code> statements.
          Without the -Z flag (default behavior), the <code class="code">ANALYZE</code> statements will
          be generated.
        </p>
              </dd>
            </dl>
          </div>
          <p>
    An example session using the loader to create an input file and loading it might look like
    this:
  </p>
          <pre class="programlisting">
# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; roads.sql
# psql -d roadsdb -f roads.sql
</pre>
          <p>
    A conversion and load can be done in one step using UNIX pipes:
  </p>
          <pre class="programlisting"># shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb</pre>
        </section>
      </section>
      <section class="section" id="extracting-data">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">4.8. Extracting Spatial Data</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <ul class="toc">
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#extract-data-sql">4.8.1. Using SQL to Extract Data</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#pgsql2shp-usage">4.8.2. Using the Shapefile Dumper</a>
              </span>
            </li>
          </ul>
        </div>
        <p>Spatial data can be extracted from the database using either SQL or the
	Shapefile dumper. The section on SQL presents some of
	the functions available to do comparisons and queries on spatial tables.
    </p>
        <section class="section" id="extract-data-sql">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.8.1. Using SQL to Extract Data</h3>
              </div>
            </div>
          </div>
          <p>The most straightforward way of extracting spatial data out of the
        database is to use a SQL <code class="code">SELECT</code> query
        to define the data set to be extracted
        and dump the resulting columns into a parsable text file:</p>
          <pre class="programlisting">db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;

road_id | geom                                    | road_name
--------+-----------------------------------------+-----------
	  1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd
	  2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd
	  3 | LINESTRING(192783 228138,192612 229814) | Paul St
	  4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave
	  5 | LINESTRING(190131 224148,190871 228134) | Phil Tce
	  6 | LINESTRING(198231 263418,198213 268322) | Dave Cres
	  7 | LINESTRING(218421 284121,224123 241231) | Chris Way
(6 rows)</pre>
          <p>There will be times when some kind of restriction is
	  necessary to cut down the number of records returned. In the case of
	  attribute-based restrictions, use the same SQL syntax as used
	  with a non-spatial table. In the case of spatial restrictions, the
	  following functions are useful:</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
                  <code class="function">ST_Intersects</code>
                </span>
              </dt>
              <dd>
                <p>This function tells whether two geometries share any space.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="code">=</code>
                </span>
              </dt>
              <dd>
                <p>This tests whether two geometries are
			geometrically identical. For example, if 'POLYGON((0 0,1 1,1 0,0
			0))' is the same as 'POLYGON((0 0,1 1,1 0,0 0))' (it is).
			</p>
              </dd>
            </dl>
          </div>
          <p>Next, you can use these operators in queries. Note that when
	  specifying geometries and boxes on the SQL command line, you must
	  explicitly turn the string representations into geometries function.
		The 312 is a fictitious spatial reference system that matches our data.
	  So, for example:</p>
          <pre class="programlisting">SELECT road_id, road_name
  FROM roads
  WHERE roads_geom='SRID=312;LINESTRING(191232 243118,191108 243242)'::geometry;</pre>
          <p>The above query would return the single record from the
	  "ROADS_GEOM" table in which the geometry was equal to that value.</p>
          <p>To check whether some of the roads passes in the area defined by a polygon:</p>
          <pre class="programlisting">SELECT road_id, road_name
FROM roads
WHERE ST_Intersects(roads_geom, 'SRID=312;POLYGON((...))');</pre>
          <p>The most common spatial query will probably be a "frame-based"
	  query, used by client software, like data browsers and web mappers, to
	  grab a "map frame" worth of data for display. </p>
          <p>When using the "&amp;&amp;" operator, you can specify either a
	  BOX3D as the comparison feature or a GEOMETRY. When you specify a
	  GEOMETRY, however, its bounding box will be used for the
	  comparison.</p>
          <p>Using a "BOX3D" object for the frame, such a query looks like this:</p>
          <pre class="programlisting">
SELECT ST_AsText(roads_geom) AS geom
FROM roads
WHERE
  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);
</pre>
          <p>Note the use of the SRID 312, to specify the projection of the envelope.</p>
        </section>
        <section class="section" id="pgsql2shp-usage">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.8.2. Using the Shapefile Dumper</h3>
              </div>
            </div>
          </div>
          <p>The <code class="filename">pgsql2shp</code> table dumper connects
	  to the database and converts a table (possibly defined by a query) into
	  a shape file. The basic syntax is:</p>
          <pre class="programlisting">
pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;
</pre>
          <pre class="programlisting">
pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;
</pre>
          <p>The commandline options are:</p>
          <div class="variablelist">
            <dl class="variablelist">
              <dt>
                <span class="term">
                  <code class="option">-f &lt;filename&gt;</code>
                </span>
              </dt>
              <dd>
                <p>Write the output to a particular filename.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-h &lt;host&gt;</code>
                </span>
              </dt>
              <dd>
                <p>The database host to connect to.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-p &lt;port&gt;</code>
                </span>
              </dt>
              <dd>
                <p>The port to connect to on the database host.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-P &lt;password&gt;</code>
                </span>
              </dt>
              <dd>
                <p>The password to use when connecting to the database.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-u &lt;user&gt;</code>
                </span>
              </dt>
              <dd>
                <p>The username to use when connecting to the database.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-g &lt;geometry column&gt;</code>
                </span>
              </dt>
              <dd>
                <p>In the case of tables with multiple geometry columns, the
			geometry column to use when writing the shape file.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-b</code>
                </span>
              </dt>
              <dd>
                <p>Use a binary cursor. This will make the operation faster,
			but will not work if any NON-geometry attribute in the table lacks
			a cast to text.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-r</code>
                </span>
              </dt>
              <dd>
                <p>Raw mode. Do not drop the <code class="varname">gid</code> field, or
			escape column names.</p>
              </dd>
              <dt>
                <span class="term">
                  <code class="option">-m filename</code>
                </span>
              </dt>
              <dd>
                <p> Remap identifiers to ten character names.
			The content of the file is lines of two symbols separated by
			a single white space and no trailing or leading space:
			VERYLONGSYMBOL SHORTONE
			ANOTHERVERYLONGSYMBOL SHORTER
			etc.</p>
              </dd>
            </dl>
          </div>
        </section>
      </section>
      <section class="section" id="build-indexes">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both">4.9. Spatial Indexes</h2>
            </div>
          </div>
        </div>
        <div class="toc">
          <ul class="toc">
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#gist_indexes">4.9.1. GiST Indexes</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#brin_indexes">4.9.2. BRIN Indexes</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#spgist_indexes">4.9.3. SP-GiST Indexes</a>
              </span>
            </li>
            <li>
              <span class="section">
                <a href="using_postgis_dbmanagement.html#tuning-index-usage">4.9.4. Tuning Index Usage</a>
              </span>
            </li>
          </ul>
        </div>
        <p>Spatial indexes make using a spatial database for large data sets
	possible. Without indexing, a search for features requires a
	sequential scan of every record in the database. Indexing speeds up
	searching by organizing the data into a structure which can be quickly
	traversed to find matching records.
    </p>
        <p>The B-tree index method commonly used for attribute data
    is not very useful for spatial data, since it only supports storing and querying
    data in a single dimension.
    Data such as geometry (which has 2 or more dimensions)
    requires an index method that supports range query across all the data dimensions.
    One of the key advantages of PostgreSQL for spatial data handling is that it offers several kinds of
	index methods which work well for multi-dimensional data: GiST, BRIN and SP-GiST indexes.</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" style="list-style-type: disc; ">
            <li class="listitem">
              <p><span class="bold"><strong>GiST (Generalized Search Tree)</strong></span> indexes break up data into
		"things to one side", "things which overlap", "things which are
		inside" and can be used on a wide range of data-types, including GIS
		data. PostGIS uses an R-Tree index implemented on top of GiST to index
		spatial data. GiST is the most commonly-used and versatile spatial index method,
        and offers very good query performance.
        </p>
            </li>
            <li class="listitem">
              <p><span class="bold"><strong>BRIN (Block Range Index)</strong></span> indexes operate by summarizing
        the spatial extent of ranges of table records.
        Search is done via a scan of the ranges.
        BRIN is only appropriate for use for some kinds of data
        (spatially sorted, with infrequent or no update).
        But it provides much faster index create time, and much smaller index size.
        </p>
            </li>
            <li class="listitem">
              <p><span class="bold"><strong>SP-GiST (Space-Partitioned Generalized Search Tree)</strong></span>
        is a generic index method that supports partitioned search trees
        such as quad-trees, k-d trees, and radix trees (tries).
        </p>
            </li>
          </ul>
        </div>
        <p>Spatial indexes store only the bounding box of geometries.
    Spatial queries use the index as a <span class="bold"><strong>primary filter</strong></span>
    to quickly determine a set of geometries potentially matching the query condition.
    Most spatial queries require a <span class="bold"><strong>secondary filter</strong></span>
    that uses a spatial predicate function to test a more specific spatial condition.
    For more information on queying with spatial predicates see <a class="xref" href="using_postgis_query.html#using-query-indexes" title="5.2. Using Spatial Indexes">Section 5.2, “Using Spatial Indexes”</a>.
    </p>
        <p>See also the
    <a class="link" href="https://postgis.net/workshops/postgis-intro/indexing.html" target="_top">PostGIS Workshop section on spatial indexes</a>,
    and the <a class="link" href="https://www.postgresql.org/docs/current/indexes.html" target="_top">PostgreSQL manual</a>.
    </p>
        <section class="section" id="gist_indexes">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.9.1. GiST Indexes</h3>
              </div>
            </div>
          </div>
          <p>GiST stands for "Generalized Search Tree" and is a generic form of
	  indexing for multi-dimensional data.
      PostGIS uses an R-Tree index implemented on top of GiST to index spatial data.
      GiST is the most commonly-used and versatile spatial index method, and offers very good query performance.
      Other implementations of GiST are used to speed up searches
	  on all kinds of irregular data structures (integer arrays, spectral
	  data, etc) which are not amenable to normal B-Tree indexing.
      For more information see the <a class="link" href="https://www.postgresql.org/docs/current/gist.html" target="_top">PostgreSQL manual</a>.
      </p>
          <p>Once a spatial data table exceeds a few thousand rows, you will want
	  to build an index to speed up spatial searches of the data (unless all
	  your searches are based on attributes, in which case you'll want to
	  build a normal index on the attribute fields).</p>
          <p>The syntax for building a GiST index on a "geometry" column is as
	  follows:</p>
          <pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] ); </pre>
          <p>The above syntax will always build a 2D-index.  To get the an n-dimensional index for the geometry type, you can create one using this syntax:</p>
          <pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] gist_geometry_ops_nd);</pre>
          <p>Building a spatial index is a computationally intensive exercise. It also blocks write access to your table for the time it creates, so on a production system you may want to do in in a slower CONCURRENTLY-aware way:</p>
          <pre class="programlisting">CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING GIST ( [geometryfield] ); </pre>
          <p>After building an index, it is sometimes helpful to force PostgreSQL to collect
		table statistics, which are used to optimize query plans:</p>
          <pre class="programlisting">VACUUM ANALYZE [table_name] [(column_name)];</pre>
        </section>
        <section class="section" id="brin_indexes">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.9.2. BRIN Indexes</h3>
              </div>
            </div>
          </div>
          <p>BRIN stands for "Block Range Index". It is a general-purpose
    index method introduced in PostgreSQL 9.5.
    BRIN is a <span class="emphasis"><em>lossy</em></span>
    index method, meaning that a secondary check is required to confirm
    that a record matches a given search condition
    (which is the case for all provided spatial indexes).
    It provides much faster index creation and much smaller index size,
    with reasonable read performance.
    Its primary purpose is to support indexing very large tables
    on columns which have a correlation with their
    physical location within the table. In addition to spatial indexing,
    BRIN can speed up searches on various kinds of attribute data
    structures (integer, arrays etc).
    For more information see the <a class="link" href="https://www.postgresql.org/docs/current/brin.html" target="_top">PostgreSQL manual</a>.
    </p>
          <p>Once a spatial table exceeds a few thousand rows, you will want
    to build an index to speed up spatial searches of the data.
    GiST indexes are very performant as long as their size doesn't exceed the amount of RAM
    available for the database, and as long as you can afford the index storage
    size, and the cost of index update on write. Otherwise, for very large tables BRIN index can be
    considered as an alternative.</p>
          <p>A BRIN index stores the bounding box enclosing
    all the geometries contained in the rows in a contiguous set of table blocks,
    called a <span class="emphasis"><em>block range</em></span>.
    When executing a query using the index the block ranges are scanned to
    find the ones that intersect the query extent.
    This is efficient only if the data is physically ordered so that the bounding
    boxes for block ranges have minimal overlap (and ideally are mutually exclusive).
    The resulting index is very small in size,
    but is typically less performant for read than a GiST index over the same data.</p>
          <p>Building a BRIN index is much less CPU-intensive than building a GiST index.
    It's common to find that a BRIN index is ten times faster to build
    than a GiST index over the same data. And because a BRIN index stores only one
    bounding box for each range of table blocks, it's common to use
    up to a thousand times less disk space than a GiST index.</p>
          <p>You can choose the number of blocks to summarize in a range. If you
    decrease this number, the index will be bigger but will probably provide
    better performance.</p>
          <p>For BRIN to be effective, the table data should be stored in
    a physical order which minimizes the amount of block extent overlap.
    It may be that the data is already sorted appropriately
    (for instance, if it is loaded from another dataset that is already sorted in spatial order).
    Otherwise, this can be accomplished by sorting the data by a one-dimensional spatial key.
    One way to do this is to create a new table sorted by the geometry values
    (which in recent PostGIS versions uses an efficient Hilbert curve ordering):
    </p>
          <pre class="programlisting">
CREATE TABLE table_sorted AS
   SELECT * FROM table  ORDER BY geom;
</pre>
          <p>Alternatively, data can be sorted in-place by using a GeoHash as a (temporary) index,
    and clustering on that index:
    </p>
          <pre class="programlisting">
CREATE INDEX idx_temp_geohash ON table
    USING btree (ST_GeoHash( ST_Transform( geom, 4326 ), 20));
CLUSTER table USING idx_temp_geohash;
</pre>
          <p>The syntax for building a BRIN index on a <code class="code">geometry</code> column is:</p>
          <pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geome_col] ); </pre>
          <p>The above syntax builds a 2D index.  To build a 3D-dimensional index, use this syntax:</p>
          <pre class="programlisting">
CREATE INDEX [indexname] ON [tablename]
    USING BRIN ([geome_col] brin_geometry_inclusion_ops_3d);</pre>
          <p>You can also get a 4D-dimensional index using the 4D operator class:</p>
          <pre class="programlisting">
CREATE INDEX [indexname] ON [tablename]
    USING BRIN ([geome_col] brin_geometry_inclusion_ops_4d);</pre>
          <p>The above commands use the default number of blocks in a range, which is 128.
    To specify the number of blocks to summarise in a range, use this syntax</p>
          <pre class="programlisting">
CREATE INDEX [indexname] ON [tablename]
    USING BRIN ( [geome_col] ) WITH (pages_per_range = [number]); </pre>
          <p>Keep in mind that a BRIN index only stores one index
    entry for a large number of rows.  If your table stores geometries with
    a mixed number of dimensions, it's likely that the resulting index will
    have poor performance.  You can avoid this performance penalty by
    choosing the operator class with the least number of dimensions of the
    stored geometries
    </p>
          <p>The <code class="code">geography</code> datatype is supported for BRIN indexing. The
    syntax for building a BRIN index on a geography column is:</p>
          <pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geog_col] ); </pre>
          <p>The above syntax builds a 2D-index for geospatial objects on the spheroid. </p>
          <p>Currently, only "inclusion support" is provided, meaning
    that just the <code class="varname">&amp;&amp;</code>, <code class="varname">~</code> and
    <code class="varname">@</code> operators can be used for the 2D cases (for both
    <code class="code">geometry</code> and <code class="code">geography</code>), and just the <code class="varname">&amp;&amp;&amp;</code>
    operator for 3D geometries.
    There is currently no support for kNN searches.</p>
          <p>An important difference between BRIN and other index types is that the database does not
    maintain the index dynamically.  Changes to spatial data in the table
    are simply appended to the end of the index.  This will cause index search performance to
    degrade over time.  The index can be updated by performing a <code class="code">VACUUM</code>,
    or by using a special function <code class="code">brin_summarize_new_values(regclass)</code>.
    For this reason BRIN may be most appropriate for use with data that is read-only,
    or only rarely changing. For more information refer to the
    <a class="link" href="https://www.postgresql.org/docs/current/brin-intro.html#BRIN-OPERATION" target="_top">manual</a>.
    </p>
          <p>To summarize using BRIN for spatial data:
    </p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>Index build time is very fast, and index size is very small.</p>
              </li>
              <li class="listitem">
                <p>Index query time is slower than GiST, but can still be very acceptable.</p>
              </li>
              <li class="listitem">
                <p>Requires table data to be sorted in a spatial ordering.</p>
              </li>
              <li class="listitem">
                <p>Requires manual index maintenance.</p>
              </li>
              <li class="listitem">
                <p>Most appropriate for very large tables,
    with low or no overlap (e.g. points),
    which are static or change infrequently.</p>
              </li>
              <li class="listitem">
                <p>More effective for queries which return relatively large numbers of data records.</p>
              </li>
            </ul>
          </div>
        </section>
        <section class="section" id="spgist_indexes">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.9.3. SP-GiST Indexes</h3>
              </div>
            </div>
          </div>
          <p>SP-GiST stands for "Space-Partitioned Generalized Search Tree" and is
		a generic form of indexing for multi-dimensional data types
        that supports partitioned search trees, such as
		quad-trees, k-d trees, and radix trees (tries).
        The common feature of these
		data structures is that they repeatedly divide the search space into
		partitions that need not be of equal size. In addition to spatial indexing,
		SP-GiST is used to speed up searches on many kinds of data, such as phone
		routing, ip routing, substring search, etc.
        For more information see the <a class="link" href="https://www.postgresql.org/docs/current/spgist.html" target="_top">PostgreSQL manual</a>.
        </p>
          <p>As it is the case for GiST indexes, SP-GiST indexes are lossy, in the
		sense that they store the bounding box enclosing spatial objects.
		SP-GiST indexes can be considered as an alternative to GiST indexes.</p>
          <p>Once a GIS data table exceeds a few thousand rows, an SP-GiST index
		may be used to speed up spatial searches of the data. The syntax for
		building an SP-GiST index on a "geometry" column is as follows:</p>
          <pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING SPGIST ( [geometryfield] ); </pre>
          <p>The above syntax will build a 2-dimensional index. A 3-dimensional
		index for the geometry type can be created using the 3D operator class:</p>
          <pre class="programlisting">CREATE INDEX [indexname] ON [tablename] USING SPGIST ([geometryfield] spgist_geometry_ops_3d);</pre>
          <p>Building a spatial index is a computationally intensive operation.
		It also blocks write access to your table for the time it creates, so on a
		production system you may want to do in in a slower CONCURRENTLY-aware way:</p>
          <pre class="programlisting">CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING SPGIST ( [geometryfield] ); </pre>
          <p>After building an index, it is sometimes helpful to force PostgreSQL to
		collect table statistics, which are used to optimize query plans:</p>
          <pre class="programlisting">VACUUM ANALYZE [table_name] [(column_name)];</pre>
          <p>An SP-GiST index can accelerate queries involving the following operators:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>&lt;&lt;, &amp;&lt;, &amp;&gt;, &gt;&gt;, &lt;&lt;|, &amp;&lt;|, |&amp;&gt;, |&gt;&gt;, &amp;&amp;, @&gt;, &lt;@, and ~=, for 2-dimensional indexes,</p>
              </li>
              <li class="listitem">
                <p> &amp;/&amp;, ~==, @&gt;&gt;, and &lt;&lt;@, for 3-dimensional indexes.</p>
              </li>
            </ul>
          </div>
          <p>There is no support for kNN searches at the moment.</p>
        </section>
        <section class="section" id="tuning-index-usage">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title">4.9.4. Tuning Index Usage</h3>
              </div>
            </div>
          </div>
          <p>Ordinarily, indexes invisibly speed up data access: once an index
	  is built, the PostgreSQL query planner automatically decides when to use it
      to improve query performance. But there are some situations
	  where the planner does not choose to use existing indexes,
      so queries end up using slow sequential scans instead of a spatial index.</p>
          <p>If you find your spatial indexes are not being used,
      there are a few things you can do:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist" style="list-style-type: disc; ">
              <li class="listitem">
                <p>Examine the query plan and check your query actually computes the
			thing you need. An erroneous JOIN, either forgotten or to the wrong table,
			can unexpectedly retrieve table records multiple times.
            To get the query plan, execute with <code class="code">EXPLAIN</code> in front of the query.</p>
              </li>
              <li class="listitem">
                <p>Make sure statistics are gathered about the number
		  and distributions of values in a table, to provide the query planner
		  with better information to make decisions around index usage.
			<span class="command"><strong>VACUUM ANALYZE</strong></span> will compute both.</p>
                <p>You should regularly vacuum your databases anyways.  Many PostgreSQL DBAs run
			<span class="command"><strong>VACUUM</strong></span> as an off-peak cron job on a regular basis.</p>
              </li>
              <li class="listitem">
                <p>If vacuuming does not help, you can temporarily force the planner to use
		    the index information by using the command <span class="command"><strong>SET ENABLE_SEQSCAN TO OFF;</strong></span>.
		    This way you can check whether the planner is at all able to generate
			an index-accelerated query plan for your query.
			You should only use this command for debugging; generally
		    speaking, the planner knows better than you do about when to use
		    indexes. Once you have run your query, do not forget to run
			<span class="command"><strong>SET ENABLE_SEQSCAN TO ON;</strong></span> so that the planner
            will operate normally for other queries.</p>
              </li>
              <li class="listitem">
                <p>If <span class="command"><strong>SET ENABLE_SEQSCAN TO OFF;</strong></span> helps your query to run faster,
		    your Postgres is likely not tuned for your hardware.
			If you find the planner wrong about the cost of sequential versus
		    index scans try reducing the value of <code class="varname">RANDOM_PAGE_COST</code> in
		    <code class="code">postgresql.conf</code>, or use <span class="command"><strong>SET RANDOM_PAGE_COST TO 1.1;</strong></span>.
            The default value for <code class="varname">RANDOM_PAGE_COST</code> is 4.0.
            Try setting it to 1.1 (for SSD) or 2.0 (for fast magnetic disks).
		    Decreasing the value makes the planner more likely to use index scans.</p>
              </li>
              <li class="listitem">
                <p>If <span class="command"><strong>SET ENABLE_SEQSCAN TO OFF;</strong></span> does not help your query,
			the query may be using a SQL construct that the Postgres planner is not yet able to optimize.
            It may be possible to rewrite the query in a way that the planner is able to handle.
			For example, a subquery with an inline SELECT may not produce an efficient plan,
            but could possibly be rewritten using a LATERAL JOIN.</p>
              </li>
            </ul>
          </div>
          <p>
        For more information see the Postgres manual section on
        <a class="link" href="https://www.postgresql.org/docs/current/runtime-config-query.html" target="_top">Query Planning</a>.
        </p>
        </section>
      </section>
    </section>
    <footer>
      <div class="navfooter">
        <table style="width: 100%; ">
          <tr>
            <td style="width: 40%; text-align: left; "><a accesskey="p" href="postgis_administration.html">Prev</a> </td>
            <td style="width: 20%; text-align: center; "> </td>
            <td style="width: 40%; text-align: right; "> <a accesskey="n" href="using_postgis_query.html">Next</a></td>
          </tr>
          <tr>
            <td style="width: 40%; text-align: left; vertical-align: top; ">Chapter 3. PostGIS Administration </td>
            <td style="width: 20%; text-align: center; ">
              <a accesskey="h" href="index.html">Home</a>
            </td>
            <td style="width: 40%; text-align: right; vertical-align: top; "> Chapter 5. Spatial Queries</td>
          </tr>
        </table>
      </div>
    </footer>
  </body>
</html>
